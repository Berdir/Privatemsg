<?php
// $Id$

/**
 * @file
 * Allows users to send private messages to other users.
 */

/**
 * Status constant for read messages.
 */
define('PRIVATEMSG_READ', 0);
/**
 * Status constant for unread messages.
 */
define('PRIVATEMSG_UNREAD', 1);

/**
 * Implementation of hook_perm().
 */
function privatemsg_perm() {
  return array(
    'read privatemsg',
    'read all private messages',
    'administer privatemsg settings',
    'write privatemsg'
  );
}

/**
 * Generate aray of user objects based on a string.
 *
 *
 * @param $userstring
 *   A string with user id, for example 1,2,4. Returned by the list query
 *
 * @return
 *   Array with user objects.
 */
function _privatemsg_generate_user_array($userstring, $slice = NULL) {
  static $user_cache = array();

  // Convert user uid list (uid1,uid2,uid3) into an array. If $slice is not NULL
  // pass that as argument to array_slice(). For example, -4 will only load the
  // last four users.
  $users = explode(',', $userstring);
  if (!is_null($slice)) {
    $users = array_slice($users, $slice);
  }
  $participants = array();
  foreach ($users as $uid) {
    if (!array_key_exists($uid, $user_cache)) {
      $user_cache[$uid] = user_load($uid);
    }
    if (is_object($user_cache[$uid])) {
      $participants[$uid] = $user_cache[$uid];
    }
  }
  return $participants;
}

/**
 * Format an array of user objects.
 *
 * @param $part_array
 *   Array with user objects, for example the one returnd by
 *   _privatemsg_generate_user_array.
 *
 * @param $limit
 *   Limit the number of user objects which should be displayed.
 * @param $no_text
 *   When TRUE, don't display the Participants/From text.
 * @return
 *   String with formated user objects, like user1, user2.
 */
function _privatemsg_format_participants($part_array, $limit = 20, $no_text = FALSE) {
  if (count($part_array) > 0) {
    $to = array();
    $limited = FALSE;
    foreach ($part_array as $account) {
      if (count($to) >= $limit) {
        $limited = TRUE;
        break;
      }
      $to[] = theme('username', $account);
    }

    $limit_string = '';
    if ($limited) {
      $limit_string = t(' and others');
    }


    if ($no_text) {
      return implode(', ', $to) . $limit_string;
    }

    $last = array_pop($to);
    if (count($to) == 0) { // Only one participant
      return t("From !last", array('!last' => $last));
    }
    else { // Multipe participants..
      $participants = implode(', ', $to);
      return t('Participants: !participants and !last', array('!participants' => $participants, '!last' => $last));
    }
  }
  return '';
}

/**
 * Implementation of hook_menu().
 */
function privatemsg_menu() {
  $items['messages'] = array(
    'title'            => 'Messages',
    'title callback'  => 'privatemsg_title_callback',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'list'),
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_NORMAL_ITEM,
  );
  $items['messages/list'] = array(
    'title'            => 'Messages',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'list'),
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'weight'           => -10,
  );
  $items['messages/view/%privatemsg_thread'] = array(
    'title'            => 'Read message',
    'page callback'    => 'privatemsg_view',
    'page arguments'   => array(2),
    'access callback'  => 'privatemsg_view_access',
    'type'             => MENU_LOCAL_TASK,
    'weight'           => -10,
  );
  $items['messages/delete/%'] = array(
    'title'            => 'Delete message',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_delete', 2),
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_CALLBACK,
    'weight'           => -10,
  );
  $items['messages/new'] = array(
    'title'            => 'Write new message',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_new', 2, 3, NULL),
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('write privatemsg'),
    'type'             => MENU_LOCAL_TASK,
    'weight'           => -7,
  );
  // Auto-completes available user names & removes duplicates.
  $items['messages/user-name-autocomplete'] = array(
    'page callback'    => 'privatemsg_user_name_autocomplete',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('write privatemsg'),
    'type'             => MENU_CALLBACK,
    'weight'           => -10,
  );
  $items['admin/settings/messages'] = array(
    'title'            => 'Private messages',
    'description'      => 'Configure private messaging settings.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('private_message_settings'),
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_NORMAL_ITEM,
  );
  $items['admin/settings/messages/default'] = array(
    'title'            => 'Private messages',
    'description'      => 'Configure private messaging settings.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('private_message_settings'),
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'weight'           => -10,
  );
  $items['messages/undo/action'] = array(
    'title'            => 'Private messages',
    'description'      => 'Undo last thread action',
    'page callback'    => 'privatemsg_undo_action',
    'access arguments' => array('read privatemsg'),
    'type'             => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Privatemsg  wrapper for user_access.
 *
 * Never allows anonymous user access as that doesn't makes sense.
 *
 * @param $permission
 *   Permission string, defaults to read privatemsg
 *
 * @return
 *   TRUE if user has access, FALSE if not
 *
 * @ingroup api
 */
function privatemsg_user_access($permission = 'read privatemsg', $account = NULL) {
  if ( $account === NULL ) {
    global $user;
    $account = $user;
  }
  if (!$account->uid) { // Disallow anonymous access, regardless of permissions
    return FALSE;
  }
  if (!user_access($permission, $account)) {
    return FALSE;
  }
  return TRUE;
}


/**
 * Check access to the view messages page.
 *
 * Function to restrict the access of the view messages page to just the
 * messages/view/% pages and not to leave tabs artifact on other lower
 * level pages such as the messages/new/%.
 *
 * @ingroup api
 */
function privatemsg_view_access() {
  if (privatemsg_user_access('read privatemsg') && arg(1) == 'view') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Load a thread with all the messages and participants.
 *
 * This function is called by the menu system through the %privatemsg_thread
 * wildcard.
 *
 * @param $thread_id
 *   Thread id, pmi.thread_id or pm.mid of the first message in that thread.
 * @param $account
 *   User object for which the thread should be loaded, defaults to
 *   the current user.
 *
 * @return
 *   $thread object, with keys messages, participants, title and user. messages
 *   contains an array of messages, participants an array of user, subject the
 *   subject of the thread and user the user viewing the thread.
 *
 *   If no messages are found, or the thread_id is invalid, the function returns
 *   FALSE.

 * @ingroup api
 */
function privatemsg_thread_load($thread_id, $account = NULL) {
  if ((int)$thread_id > 0) {
    $thread = array('thread_id' => $thread_id);

    if (is_null($account)) {
      global $user;
      $account = drupal_clone($user);
    }
    // load messages returned by the messages query with _privatemsg_load().
    $query = _privatemsg_assemble_query('messages', array($thread_id), $account);
    $conversation = db_query($query['query']);
    while ($result = db_fetch_array($conversation)) {
      if ($message = _privatemsg_load($result['mid'], $account)) {
        $thread['messages'][$result['mid']] = $message;
      }
    }
    // if there are no messages, don't allow access to the thread.
    if (empty($thread['messages'])) {
      return FALSE;
    }

    // general data, assume subject is the same for all messages of that thread.
    $thread['user'] = $account;
    $message = current($thread['messages']);
    $thread['subject'] = $message['subject'];

    // Load the list of participants.
    $query = _privatemsg_assemble_query('participants', $thread_id);
    $participants = db_query($query['query']);
    while ($result = db_fetch_array($participants)) {
      $thread['participants'][$result['uid']] = user_load($result['uid']);
    }
    return $thread;
  }
  return FALSE;
}

function private_message_view_options() {
  $options = module_invoke_all('privatemsg_view_template');
  return $options;
}

/**
 * Implementation of hook_privatemsg_view_template().
 *
 * Allows modules to define different message view template.
 *
 * This hook returns information about available themes for privatemsg viewing.
 *
 * array(
 *  'machine_template_name' => 'Human readable template name',
 *  'machine_template_name_2' => 'Human readable template name 2'
 * };
 */
function privatemsg_privatemsg_view_template() {
  return array(
    'privatemsg-view' => 'Default view',
  );
}

function private_message_settings() {
  $form = array();

  $form['theming_settings'] = array(
    '#type'        => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#title'       => t('Theming settings'),
  );
  $form['theming_settings']['private_message_view_template'] = array(
    '#type'          => 'radios',
    '#title'         => t('Private message display template'),
    '#default_value' => variable_get('private_message_view_template', 'privatemsg-view'),
    '#options'       => private_message_view_options(),
  );
  $form['privatemsg_per_page'] = array(
    '#type' => 'select',
    '#title' => t('Messages per page'),
    '#default_value' => variable_get('privatemsg_per_page', 25),
    '#options' => drupal_map_assoc(array(10, 25, 50, 75, 100)),
    '#description' => t('Choose the number of conversations that should be listed per page.'),
  );
  $form['privatemsg_display_loginmessage'] = array(
    '#type' => 'checkbox',
    '#title' => t('Inform the user about new messages on login'),
    '#default_value' => variable_get('privatemsg_display_loginmessage', TRUE),
    '#description' => t('This option can safely be disabled if the "New message indication" block is used instead.'),
  );
  $form['privatemsg_listing'] = array(
    '#type' => 'fieldset',
    '#title' => t('Configure listings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['privatemsg_listing']['privatemsg_display_fields'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Configure fields'),
    '#description' => t('Select which columns/fields should be displayed in the message listings. Subject and Last updated cannot be disabled.'),
    '#options' => array(
      'participants'    => t('Participants'),
      'thread_started'  => t('Started'),
      'count'           => t('Answers'),
    ),
    '#default_value' => variable_get('privatemsg_display_fields', array('participants')),
  );

  $form['#submit'][] = 'private_message_settings_submit';
  return system_settings_form($form);
}

function private_message_settings_submit() {
  drupal_rebuild_theme_registry();
}

function privatemsg_theme() {
  return array(
    'privatemsg_view'    => array(
      'arguments'        => array('message' => NULL),
      'template'         => variable_get('private_message_view_template', 'privatemsg-view'), // 'privatemsg',
    ),
    'privatemsg_from'    => array(
      'arguments'        => array('author' => NULL),
      'template'         => 'privatemsg-from',
    ),
    'privatemsg_to'      => array(
      'arguments'        => array('message' => NULL),
      'template'         => 'privatemsg-recipients',
    ),
    'privatemsg_between' => array(
      'arguments'        => array('recipients' => NULL),
      'template'         => 'privatemsg-between',
    ),
    'privatemsg_list'    => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'arguments'        => array('form'),
    ),
    // Define pattern for header/field templates. The theme system will register all
    // theme functions that start with the defined pattern.
    'privatemsg_list_header'  => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'pattern'               => 'privatemsg_list_header__',
      'arguments'             => array(),
    ),
    'privatemsg_list_field'   => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'pattern'               => 'privatemsg_list_field__',
      'arguments'             => array('thread'),
    ),
    'privatemsg_new_block'  => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'arguments'             => array('count'),
    ),
  );
}

function privatemsg_preprocess_privatemsg_view(&$vars) {
//  drupal_set_message('<pre>'. print_r($vars,1 ) . '</pre>');

  $message = $vars['message'];
  $vars['mid'] = isset($message['mid']) ? $message['mid']:null;
  $vars['author_picture'] = theme('user_picture', $message['author']);
  $vars['author_name_link'] = theme('username', $message['author']);
  /**
   * @todo perhaps make this timestamp configurable via admin UI?
   */
  $vars['message_timestamp'] = format_date($message['timestamp'], 'small');
  $vars['message_body'] = check_markup($message['body']);
  if (isset($vars['mid'])) {
    $vars['message_actions'][] = array('title' => t('Delete message'), 'href' => 'messages/delete/'. $vars['mid']);
  }

  // call hook_privatemsg_message_view_alter
  drupal_alter('privatemsg_message_view', $vars);

  $vars['message_actions'] = !empty($vars['message_actions']) ? theme('links', $vars['message_actions'], array('class' => 'message-actions')) : '';
}

function privatemsg_preprocess_privatemsg_to(&$vars) {
  $vars['participants'] = ''; // assign a default empty value
  if (isset($vars['message']['participants'])) {
    $vars['participants'] = _privatemsg_format_participants($vars['message']['participants']);
  }
}

/**
 * List messages.
 *
 * @param $form_state
 *   Form state array
 * @param $argument
 *   An argument to pass through to the query builder.
 * @param $uid
 *   User id messages of another user should be displayed
 *
 * @return
 *   Form array
 */
function privatemsg_list(&$form_state, $argument = 'list', $uid = NULL) {
  global $user;

  // Setting default behavior...
  $account = $user;
  // Because uid is submitted by the menu system, it's a string not a integer.
  if ((int)$uid > 0 && $uid != $user->uid) {
    // Trying to view someone else's messages...
    if (!privatemsg_user_access('read all private messages')) {
      drupal_set_message(t("You do not have sufficient rights to view someone else's messages"), 'warning');
    }
    elseif ($account_check = user_load(array('uid' => $uid))) {
      // Has rights and user_load return an array so user does exist
      $account = $account_check;
    }
  }
  // By this point we have figured out for which user we are listing messages and now it is safe to use $account->uid in the listing query.

  $query = _privatemsg_assemble_query('list', $account, $argument);
  $result = pager_query($query['query'], variable_get('privatemsg_per_page', 25), 0, $query['count']);

  $threads = array();
  $form['#data'] = array();
  while ($row = db_fetch_array($result)) {
    // Store the raw row data.
    $form['#data'][$row['thread_id']] = $row;
    // Store the themed row data.
    $form['#rows'][$row['thread_id']] = _privatemsg_list_thread($row);
    // store thread id for the checkboxes array
    $threads[$row['thread_id']] = '';
  }
  if (empty($form['#data'])) {
    // If no threads are displayed, use these default columns.
    $keys = array('subject', 'author', 'last_updated');
  }
  else {
    // Load the keys of the first row in data, we don't know the key
    $keys = array_keys($form['#data'][key($form['#data'])]);
    $form['actions'] = _privatemsg_action_form();
  }
  // Load the themed list headers based on the available data
  $form['#headers'] = _privatemsg_list_headers(!empty($form['#data']), $keys);

  // Define checkboxes, pager and theme
  $form['threads'] = array('#type' => 'checkboxes', '#options' => $threads);
  $form['pager'] = array('#value' => theme('pager'), '#weight' => 20);
  $form['#theme'] = 'privatemsg_list';

  // Store the account for which the threads are displayed.
  $form['#account'] = $account;
  return $form;
}

/**
 * Changes the read/new status of a single message.
 *
 * @param $pmid
 *   Message id
 * @param $status
 *   Either PRIVATEMSG_READ or PRIVATEMSG_UNREAD
 * @param $account
 *   User object, defaults to the current user
 */
function privatemsg_message_change_status($pmid, $status, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  $query = "UPDATE {pm_index} SET is_new = %d WHERE mid = %d AND uid = %d";
  db_query($query, $status, $pmid, $account->uid);
}

/**
 * Return number of unread messages for an account.
 *
 * @param $account
 *   Specifiy the user for which the unread count should be loaded.
 *
 * @ingroup api
 */
function privatemsg_unread_count($account = NULL) {
  static $counts = array();
  if (!$account || $account->uid == 0) {
    global $user;
    $account = $user;
  }
  if ( !isset($counts[$account->uid])) {
    $query = _privatemsg_assemble_query('unread_count', $account);
    $counts[$account->uid] = db_result(db_query($query['query']));
  }
  return $counts[$account->uid];
}

/**
 * Menu callback for viewing a thread.
 *
 * @param $thread
 *   A array containing all information about a specific thread, generated by
 *   privatemsg_thread_load().
 * @return
 *   The page content.
 * @see privatemsg_thread_load().
 */
function privatemsg_view($thread) {
  drupal_set_title(check_plain($thread['subject']));

  // Render the participants.
  $content['participants']['#value'] = theme('privatemsg_to', $thread);
  $content['participants']['#weight'] = -5;

  // Render the messages.
  $output = '';
  foreach ($thread['messages'] as $pmid => $message) {
    // Set message as read and theme it.
    if (!empty($message['is_new'])) {
      privatemsg_message_change_status($pmid, PRIVATEMSG_READ, $thread['user']);
    }
    $output .= theme('privatemsg_view', $message);
  }
  $content['messages']['#value'] = $output;
  $content['messages']['#weight'] = 0;

  // Display the reply form if user is allowed to use it.
  if (privatemsg_user_access('write privatemsg')) {
    $content['reply']['#value'] = drupal_get_form('privatemsg_new', $thread['participants'], $thread['subject'], $thread['thread_id']);
    $content['reply']['#weight'] = 5;
  }

  //allow other modules to hook into the $content array and alter it
  drupal_alter('privatemsg_view_messages', $content, $thread);
  return drupal_render($content);
}


function privatemsg_new(&$form_state, $recipients = array(), $subject = '', $thread_id = NULL) {
  global $user;

  $recipients_string = '';
  $body      = '';

  // convert recipients to array of user objects
  if (!empty($recipients) && is_string($recipients) || is_int($recipients)) {
    $recipients = _privatemsg_generate_user_array($recipients);
  }
  elseif (is_object($recipients)) {
    $recipients = array($recipients);
  }
  elseif (empty($recipients) && is_string($recipients)) {
    $recipients = array();
  }

  $usercount = 0;
  $to = array();
  foreach ($recipients as $recipient) {
    if (in_array($recipient->name, $to)) {
      // We already added the recipient to the list, skip him.
      continue;
    }
    // Check if another module is blocking the sending of messages to the recipient by current user.
    $user_blocked = module_invoke_all('privatemsg_block_message', $user, array($recipient));
    if (!count($user_blocked) <> 0 && $recipient->uid) {
      if ($recipient->uid == $user->uid) {
        $usercount++;
        // Skip putting author in the recipients list for now.
        continue;
      }
      $to[] = $recipient->name;
    }
  }

  if (empty($to) && $usercount >= 1) {
    // Assume the user sent message to own account as if the usercount is one or less, then the user sent a message but not to self.
    $to[] = $user->name;
  }


  if (!empty($to)) {
    $recipients_string = implode(', ', $to);
  }
  if (isset($form_state['values'])) {
    $recipients_string = $form_state['values']['recipient'];
    $subject   = $form_state['values']['subject'];
    $body      = $form_state['values']['body'];
  }
  if (!$thread_id && !empty($recipients_string)) {
    drupal_set_title(t('Write new message to %recipient', array('%recipient' => $recipients_string)));
  } elseif (!$thread_id) {
    drupal_set_title(t('Write new message'));
  }

  $form = array();
  if (isset($form_state['privatemsg_preview'])) {
    $form['message_header'] = array(
      '#type' => 'fieldset',
      '#attributes' => array('class' => 'preview'),
    );
    $form['message_header']['message_preview'] = array(
      '#value'  => $form_state['privatemsg_preview'],
    );
  }
  $form['privatemsg'] = array(
    '#type'               => 'fieldset',
    '#access'             => privatemsg_user_access('write privatemsg'),
  );
  $form['privatemsg']['author'] = array(
    '#type' => 'value',
    '#value' => $user,
  );
  $form['privatemsg']['recipient']  = array(
    '#type'               => 'textfield',
    '#title'              => t('To'),
    '#description'        => t('Separate multiple names with commas.'),
    '#default_value'      => $recipients_string,
    '#required'           => TRUE,
    '#weight'             => -10,
    '#size'               => 50,
    '#autocomplete_path'  => 'messages/user-name-autocomplete',
    // Do not hardcode #maxlength, make it configurable by number of recipients, not their name length.
  );
  $form['privatemsg']['subject']    = array(
    '#type'               => 'textfield',
    '#title'              => t('Subject'),
    '#size'               => 50,
    '#maxlength'          => 255,
    '#default_value'      => $subject,
    '#weight'             => -5,
  );
  $form['privatemsg']['body']       = array(
    '#type'               => 'textarea',
    '#title'              => t('Message'),
    '#cols'               => 10,
    '#rows'               => 6,
    '#weight'             => 0,
    '#default_value'      => $body,
  );
  $form['privatemsg']['preview'] = array(
    '#type'               => 'submit',
    '#value'              => t('Preview message'),
    '#submit'             => array('pm_preview'),
    '#weight'             => 10,
  );
  $form['privatemsg']['submit'] = array(
    '#type'               => 'submit',
    '#value'              => t('Send message'),
    '#submit'             => array('pm_send'),
    '#weight'             => 15,
  );
  $url = 'messages';
  if (isset($_REQUEST['destination'])) {
    $url = $_REQUEST['destination'];
  }
  elseif (!is_null($thread_id)) {
    $url = $_GET['q'];
  }

  $form['privatemsg']['cancel'] = array(
    '#value'              => l(t('Cancel'), $url, array('attributes' => array('id' => 'edit-cancel'))),
    '#weight'             => 20,
  );
  $form['#validate'][]    = 'pm_send_validate';

  if (!is_null($thread_id)) {
    $form['privatemsg']['thread_id'] = array(
      '#type' => 'value',
      '#value' => $thread_id,
    );
    $form['privatemsg']['subject'] = array(
          '#type' => 'value',
          '#default_value' => $subject,
    );
    $form['privatemsg']['recipient_display'] = array(
      '#value' =>  '<p>'. t('<strong>Reply to thread</strong>:<br /> Recipients: %to', array('%to' => $recipients_string)) .'</p>',
      '#weight' => -10,
    );
    $form['privatemsg']['recipient']  = array(
      '#type' => 'value',
      '#default_value' => $recipients_string,
    );
    if (empty($recipients_string)) {
      // If there are no valid recipients, unset the message reply form.
      $form['privatemsg']['#access'] = FALSE;
    }
  }
  return $form;
}

function pm_send_validate($form, &$form_state) {
  // The actual message that is being sent, we create this during validation and pass to submit to send out.
  $message = array();

  $message['body']      = $form_state['values']['body'];
  $message['subject']   = $form_state['values']['subject'];
  $message['author']    = $form_state['values']['author'];
  $message['timestamp'] = time();
  if (isset($form_state['values']['thread_id']) && $form_state['values']['thread_id']) {
    $message['thread_id'] = $form_state['values']['thread_id'];
  }

  $trimed_body = trim(truncate_utf8(strip_tags($message['body']), 50, TRUE, TRUE));
  if (empty($message['subject']) && !empty($trimed_body)) {
    $message['subject'] = $trimed_body;
  }

  list($message['recipients'], $invalid) = _privatemsg_parse_userstring($form_state['values']['recipient']);

  $validated = _privatemsg_validate_message($message, TRUE);
  foreach ($validated['messages'] as $type => $text) {
    drupal_set_message($text, $type);
  }
  $form_state['validate_built_message'] = $message;
  if (!empty($invalid)) {
    drupal_set_message(t('The following users will not receive this private message: !invalid', array('!invalid' => implode(", ", $invalid))), 'error');
  }
}

/**
 * Extract the valid usernames of a string and loads them.
 *
 * This function is used to parse a string supplied by a username autocomplete
 * field and load all user objects.
 *
 * @param $string
 *   A string in the form "usernameA, usernameB, ...".
 * @return
 *   Array, first element is an array of loaded user objects, second an array
 *   with invalid names.
 *
 */
function _privatemsg_parse_userstring($string) {
  // Verify that recipient's name syntax is correct.
  $fragments = explode(',', $string);
  $invalid = array();
  $valid   = array();
  foreach ($fragments as $index => $name) {
    $name = trim($name);
    if (!empty($name)) { // We don't care about white space names.
      if (empty($name) || $error = module_invoke('user', 'validate_name', $name)) {
        // These names are invalid due to incorrect user name syntax.
        $invalid[$name] = $name;
      }
      else {
        $valid[$name] = $name;  // These are valid only due to user name syntax. We still need to check if the user exists and accepts messages.
      }
    }
  }

  // Verify users exist and load their accounts.
  $users = array();
  foreach ($valid as $index => $name) {
    if ($recipient = user_load(array('name' => $name))) {
      $users[$recipient->uid] = $recipient;
    }
    else {
      // Here we add more invalid names due to the fact that they don't exist.
      $invalid[$name] = $name;
    }
  }
  return array($users, $invalid);
}

function pm_send($form, &$form_state) {
  if (_privatemsg_send($form_state['validate_built_message'])) {    // Load usernames to which the message was sent to
    $recipient_names = array();
    foreach ($form_state['validate_built_message']['recipients'] as $recipient) {
      $recipient_names[] = theme('username', $recipient);
    }
    drupal_set_message(t('A message has been sent to !recipients.', array('!recipients' => implode(', ', $recipient_names))));
  }
}

function pm_preview($form, &$form_state) {

    drupal_validate_form($form['form_id']['#value'], $form, $form_state);
    if (!form_get_errors()) {
      $form_state['privatemsg_preview'] = theme('privatemsg_view', $form_state['validate_built_message']);
    }

  $form_state['rebuild'] = TRUE; // this forces our form to be rebuilt instead of being submitted.
}

function privatemsg_sql_list(&$fragments, $account, $argument = 'list') {
  $fragments['primary_table'] = '{pm_message} pm';

  // Load enabled columns
  $fields = array_filter(variable_get('privatemsg_display_fields', array('participants')));

  // Required columns
  $fragments['select'][]      = 'pmi.thread_id';
  $fragments['select'][]      = 'MIN(pm.subject) as subject';
  $fragments['select'][]      = 'MAX(pm.timestamp) as last_updated';
  $fragments['select'][]      = 'MAX(pmi.is_new) as is_new';

  if (in_array('count', $fields)) {
    $fragments['select'][]      = 'COUNT(distinct pmi.mid) as count'; // We only want the distinct number of messages in this thread.
  }
  if (in_array('participants', $fields)) {
    // Query for a string with uid's, for example "1,6,7". This needs a subquery on PostgreSQL.
    if ($GLOBALS['db_type'] == 'pgsql') {
       $fragments['select'][]      = "array_to_string(array(SELECT DISTINCT textin(int4out(pmia.uid))
                                                            FROM {pm_index} pmia
                                                            WHERE pmia.thread_id = pmi.thread_id), ',') AS participants";
    }
    else {
       $fragments['select'][]      = '(SELECT GROUP_CONCAT(DISTINCT pmia.uid SEPARATOR ",")
                                                            FROM {pm_index} pmia
                                                            WHERE pmia.thread_id = pmi.thread_id) AS participants';
    }
  }
  if (in_array('thread_started', $fields)) {
    $fragments['select'][]      = 'MIN(pm.timestamp) as thread_started';
  }
  // pm_index needs to be the first join.
  $fragments['inner_join'][]  = 'INNER JOIN {pm_index} pmi ON pm.mid = pmi.mid';
  $fragments['where'][]       = 'pmi.uid = %d';
  $fragments['query_args']['where'][]  = $account->uid;
  $fragments['where'][]       = 'pmi.deleted = 0';
  $fragments['group_by'][]    = 'pmi.thread_id';

  // We can use tablesort_sql now, but we don't need the ORDER BY part of the query.
  // Because of that, we need to cut off the first 9 characters of the generated string
  $order_by = drupal_substr(tablesort_sql(_privatemsg_list_headers( FALSE, array('subject', 'last_updated') + $fields), 'is_new DESC,'), 9);
  $fragments['order_by'][]  = $order_by;
}

/**
 * @addtogroup sql
 * @{
 */

/**
 * Query function for load.
 */
function privatemsg_sql_load(&$fragments, $pmid, $account) {
//  drupal_set_message('<pre>'. print_r(func_get_args(), 1) . '</pre>');
  $fragments['primary_table'] = '{pm_message} pm'; // Our primary table

  $fragments['select'][]      = "pm.mid";
  $fragments['select'][]      = "pm.author";
  $fragments['select'][]      = "pm.subject";
  $fragments['select'][]      = "pm.body";
  $fragments['select'][]      = "pm.timestamp";
  $fragments['select'][]      = "pmi.is_new";

  $fragments['inner_join'][]  = 'INNER JOIN {pm_index} pmi ON pm.mid = pmi.mid';
  $fragments['where'][]       = 'pmi.mid = %d';
  $fragments['query_args']['where'][]  = $pmid;
  $fragments['where'][]       = 'pmi.uid = %d';
  $fragments['query_args']['where'][]  = $account->uid;
}
/**
 * Query definition to load messages of one or multiple threads.
 *
 * @param $fragments
 *  Query fragments array.
 * @param $threads
 *  Array with one or multiple thread id's.
 * @param $account
 *  User object for which the messages are being loaded.
 * @param $load_all
 *  Deleted messages are only loaded if this is set to TRUE.
 */
function privatemsg_sql_messages(&$fragments, $threads, $account, $load_all = FALSE) {
  $fragments['primary_table'] = '{pm_index} pmi';

  $fragments['select'][]      = 'DISTINCT(pmi.mid) as mid';
  $fragments['where'][]       = 'pmi.thread_id IN ('. db_placeholders($threads) .')';
  $fragments['query_args']['where']   += $threads;
  $fragments['where'][]       = 'pmi.uid = %d';
  $fragments['query_args']['where'][]  = $account->uid;
  if (!$load_all) {
    $fragments['where'][]       = 'pmi.deleted = 0';
  }
  $fragments['order_by'][]    = 'pmi.mid ASC';
}

function privatemsg_sql_participants(&$fragments, $thread_id) {
  $fragments['primary_table'] = '{pm_index} pmi';

  $fragments['select'][]      = 'DISTINCT(pmi.uid) as uid';
  $fragments['where'][]       = 'pmi.thread_id = %d';
  $fragments['query_args']['where'][]  = $thread_id;
}


function privatemsg_sql_unread_count(&$fragments, $account) {
  $fragments['primary_table'] = '{pm_index} pmi';

  $fragments['select'][]      = 'COUNT(DISTINCT thread_id) as unread_count';
  $fragments['where'][]       = 'pmi.deleted = 0';
  $fragments['where'][]       = 'pmi.is_new = 1';
  $fragments['where'][]       = 'pmi.uid = %d';
  $fragments['query_args']['where'][]  = $account->uid;
}

function privatemsg_sql_autocomplete(&$fragments, $search, $names) {
  $fragments['primary_table'] = '{users} u';
  $fragments['select'][] = 'u.name';
  $fragments['where'][] = "u.name LIKE '%s'";
  $fragments['query_args']['where'][] = $search .'%%';
  if (!empty($names)) {
    $fragments['where'][] = "u.name NOT IN (". db_placeholders($names, 'text') .")";
    $fragments['query_args']['where'] += $names;
  }
  $fragments['where'][] = 'u.status <> 0';
  $fragments['order_by'][] = 'u.name ASC';
}

/**
 * @}
 */

/**
 * Return autocomplete results for usernames.
 *
 * Prevents usernames from being used and/or suggested twice.
 */
function privatemsg_user_name_autocomplete($string) {
  $names = array();
  // 1: Parse $string and build list of valid user names.
  $fragments = explode(',', $string);
  foreach ($fragments as $index => $name) {
    $name = trim($name);
    if ($error = module_invoke('user', 'validate_name', $name)) {
      // Do nothing if this name does not validate.
    }
    else {
      $names[$name] = $name;
    }
  }

  // By using user_validate_user we can ensure that names included in $names are at least logisticaly possible.
  // 2: Find the next user name suggestion.
  $fragment = array_pop($names);
  $matches = array();
  if (!empty($fragment)) {
    $query = _privatemsg_assemble_query('autocomplete', $fragment, $names);
    $result = db_query_range($query['query'], $fragment, 0, 10);
    $prefix = count($names) ? implode(", ", $names) .", " : '';
    // 3: Build proper suggestions and print.
    while ($user = db_fetch_object($result)) {
      $matches[$prefix . $user->name .", "] = $user->name;
    }
  }
  // convert to object to prevent drupal bug, see http://drupal.org/node/175361
  drupal_json((object)$matches);
}

function privatemsg_user($op, &$edit, &$account, $category = NULL) {
  global $user;


  switch ($op) {
    case 'view':
      if ($url = privatemsg_get_link(array($account))) {
        $account->content['privatemsg_send_new_message'] = array(
          '#type'   => 'markup',
          '#value'  => l(t('Send this user a message'), $url, array('query' => drupal_get_destination())),
          '#weight' => 10,
        );
      }
      break;
    case 'login':
      if (variable_get('privatemsg_display_loginmessage', TRUE) && privatemsg_user_access()) {
        $count = privatemsg_unread_count();
        if ($count) {
          drupal_set_message(t('You have <a href="@messages">%unread</a>.', array('@messages' => url('messages'), '%unread' => format_plural($count, '1 unread message', '@count unread messages'))));
        }
      }
      break;
  }
}

function privatemsg_block($op = 'list', $delta = 0, $edit = array()) {
  if ('list' == $op) {
    $blocks = array();
    $blocks['privatemsg-menu'] = array(
      'info' => t('Privatemsg links'),
      'cache' => BLOCK_NO_CACHE,
    );
    $blocks['privatemsg-new'] = array(
      'info' => t('New message indication'),
      'cache' => BLOCK_NO_CACHE,
    );

    return $blocks;
  }
  elseif ('view' == $op) {
    $block = array();
    switch ($delta) {
      case 'privatemsg-menu':
        $block = _privatemsg_block_menu();
        break;
      case 'privatemsg-new':
        $block = _privatemsg_block_new();
        break;
    }
    return $block;
  }
}

function privatemsg_title_callback($title = NULL) {
  $count = privatemsg_unread_count();

  if ($count > 0) {
    return format_plural($count, 'Messages (1 new)', 'Messages (@count new)');
  }
  return t('Messages');
}


function _privatemsg_block_new() {
  $block = array();

  if (!privatemsg_user_access()) {
    return $block;
  }

  $count = privatemsg_unread_count();
  if ($count) {
    $block = array(
      'subject' => format_plural($count, 'New message', 'New messages'),
      'content' => theme('privatemsg_new_block', $count),
    );
    return $block;
  }
  return array();
}

function _privatemsg_block_menu() {
  $block = array();

  $links = array();
  if (privatemsg_user_access('write privatemsg')) {
    $links[] = l(t('Write new message'), 'messages/new');
  }
  if (privatemsg_user_access('read privatemsg') || privatemsg_user_access('read all private messages') ) {
    $links[] = l(privatemsg_title_callback(), 'messages');
  }
  if ( count( $links ) ) {
    $block = array(
      'subject' => t('Private messages'),
      'content' => theme('item_list', $links),
    );
  }
  return $block;
}

function privatemsg_delete($form_state, $pmid) {
  global $user;

  $form['pmid'] = array(
    '#type' => 'value',
    '#value' => $pmid,
  );
  return confirm_form($form,
    t('Are you sure you want to delete'),
    isset($_GET['destination']) ? $_GET['destination'] : 'messages/view/'. $pmid,
    t('This action cannot be undone.'),
    t('Delete'),
    t('Cancel')
  );
}

/**
 * Delete or restore a message.
 *
 * @param $pmid
 *   Message id, pm.mid field.
 * @param $delete
 *   Either deletes or restores the thread (1 => delete, 0 => restore)
 * @param $account
 *   User acccount for which the message should be deleted.
 *
 * @ingroup api
 */
function privatemsg_message_change_delete($pmid, $delete, $account = NULL) {
  if (is_null($account)) {
    global $user;
    $account = drupal_clone($user);
  }
  $message = _privatemsg_load($pmid, $account);

  db_query('UPDATE {pm_index} SET deleted = %d WHERE mid = %d AND uid = %d', $delete, $pmid, $account->uid);

  $result = db_query("SELECT MIN(deleted) AS deleted_by_all FROM {pm_index} WHERE mid = %d", $pmid);
  $deleted = db_fetch_array($result);

  $deleted_by_all = FALSE;
  if ($deleted['deleted_by_all'] == 0) {
    $deleted_by_all = TRUE;
  }

  module_invoke_all('privatemsg_message_delete', $message, $deleted_by_all);
}

function privatemsg_delete_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    privatemsg_message_change_delete($form_state['values']['pmid'], 1);
    drupal_set_message(t('Message has been deleted'));
  }
  $form_state['redirect'] = 'messages';
}
/**
 * Send a new message.
 *
 * This functions does send a message in a new thread.
 * Example:
 * @code
 * privatemsg_new_thread(array(user_load(5)), 'The subject', 'The body text');
 * @endcode
 *
 * @param $recipients
 *   Array of recipients (user objects)
 * @param $subject
 *   The subject of the new message
 * @param $body
 *   The body text of the new message
 * @param $options
 *   Additional options, possible keys:
 *     author => User object of the author
 *     timestamp => Time when the message was sent
 *
 * @return
 *   Either true or an array with validation errors
 *
 * @ingroup api
 */
function privatemsg_new_thread($recipients, $subject, $body = NULL, $options = array()) {
  global $user;
  $author = drupal_clone($user);

  $message = array();
  $message['subject'] = $subject;
  $message['body'] = $body;
  $message['recipients'] = $recipients;

  // Set custom options, if any.
  if (!empty($options)) {
    $message += $options;
  }
  // Apply defaults - this will not overwrite existing keys.
  $message += array(
    'author' => $author,
    'timestamp' => time(),
  );

  $validated = _privatemsg_validate_message($message);
  if ($validated['success']) {
    $validated['success'] = _privatemsg_send($message);
  }

  return $validated;
}
/**
 * Send a reply message
 *
 * This functions replies on an existing thread.
 *
 * @param $thread_id
 *   Thread id
 * @param $body
 *   The body text of the new message
 * @param $options
 *   Additional options, possible keys:
 *     author => User object of the author
 *     timestamp => Time when the message was sent
 *
 * @return
 *   Either true or an array with validation errors
 *
 * @ingroup api
 */
function privatemsg_reply($thread_id, $body = NULL, $options = array()) {
  global $user;
  $author = drupal_clone($user);

  $message = array();
  $message['body'] = $body;

  // set custom options, if any
  if (!empty($options)) {
    $message += $options;
  }
  // apply defaults
  $message += array(
    'author' => $author,
    'timestamp' => time(),
  );

  // We don't know the subject and the recipients, so we need to load them..
  // thread_id == mid on the first message of the thread
  $first_message = _privatemsg_load($thread_id, $message['author']);
  if (!$first_message) {
    return array(t('Thread %thread_id not found, unable to answer', array('%thread_id' => $thread_id)));
  }

  $message['thread_id'] = $thread_id;

  $query = _privatemsg_assemble_query('participants', $thread_id);
  $participants = db_query($query['query']);
  while ($result = db_fetch_object($participants)) {
    $recipient = user_load($result->uid);
      $message['recipients'][$recipient->uid] = $recipient;
  }

  $message['subject'] = $first_message['subject'];

  $validated = _privatemsg_validate_message($message);
  if ($validated['success']) {
    $validated['success'] = _privatemsg_send($message);
  }
  return $validated;
}

function _privatemsg_validate_message(&$message, $form = FALSE) {
  $messages = array('error' => array(), 'warning' => array());
  if (!privatemsg_user_access('write privatemsg', $message['author'])) {
    // no need to do further checks in this case...
    if ($form) {
      form_set_error('author', t('User @user is not allowed to write messages', array('@user' => $message['author']->name)));
      return array(
        'success'  => FALSE,
        'messages'   => $messages,
      );
    }
    else {
      $messages['error'][] = t('User @user is not allowed to write messages', array('@user' => $message['author']->name));
      return array(
         'success'  => FALSE,
         'messages'   => $messages,
      );
    }
  }

  if (empty($message['subject'])) {
    if ($form) {
      form_set_error('subject', t('Disallowed to send a message without subject'));
    }
    else {
      $messages['error'][] = t('Disallowed to send a message without subject');
    }
  }

  if (empty($message['recipients']) || !is_array($message['recipients'])) {
    if ($form) {
      form_set_error('to', t('Disallowed to send a message without atleast one valid recipient'));
    }
    else {
      $messages['error'][] = t('Disallowed to send a message without atleast one valid recipient');
    }
  }

  if (!empty($message['recipients']) && is_array($message['recipients'])) {
    foreach(module_invoke_all('privatemsg_block_message', $message['author'], $message['recipients']) as $blocked) {
      unset($message['recipients'][$blocked['uid']]);
      if ($form) {
        drupal_set_message($blocked['message'], 'warning');
      } else {
        $messages['warning'][] = $blocked['message'];
      }
    }
  }

  // Check again, give another error message if all recipients are blocked
  if (empty($message['recipients'])) {
    if ($form) {
      form_set_error('to', t('Disallowed to send message because all recipients are blocked'));
    }
    else {
      $messages['error'][] = t('Disallowed to send message because all recipients are blocked');
    }
  }

  $messages += module_invoke_all('privatemsg_message_validate', $message, $form);
  $success = empty($messages['error']);
  return array(
    'success'  => $success,
    'messages'   => $messages,
  );
}

function _privatemsg_send($message) {

  drupal_alter('privatemsg_message_presave', $message);

  // 1) Save the message body first.
  $args = array();
  $args[] = $message['subject'];
  $args[] = $message['author']->uid;
  $args[] = $message['body'];
  $args[] = $message['timestamp'];
  $query = "INSERT INTO {pm_message} (subject, author, body, timestamp) VALUES ('%s', %d, '%s', %d)";
  $resuld = db_query($query, $args);
  $mid = db_last_insert_id('pm_message', 'mid');
  $message['mid'] = $mid;

  // Thread ID is the same as the mid if it's the first message in the thread.
  if (!isset($message['thread_id'])) {
    $message['thread_id'] = $mid;
  }

  // 2) Save message to recipients.
  // Each recipient gets a record in the pm_index table.

  $query = "INSERT INTO {pm_index} (mid, thread_id, uid, is_new, deleted) VALUES (%d, %d, %d, %d, 0)";
  foreach ($message['recipients'] as $recipient) {

    db_query($query, $mid, $message['thread_id'], $recipient->uid, 1);
  }

  // When author is also the recipient, we want to set message to UNREAD. all other times his message is set to read
  $is_new = isset($message['recipients'][$message['author']->uid]) ? 1 : 0;

  // Also add a record for tha author to the pm_index table - set  column "new" to 0.
  db_query($query, $mid, $message['thread_id'], $message['author']->uid, $is_new);

  module_invoke_all('privatemsg_message_insert', $message);

  return TRUE;
}

/**
 * Returns a link to send message form for a specific users.
 *
 * Contains permission checks of author/recipient, blocking and
 * if a anonymous user is involved.
 *
 * @param $recipient
 *   Recipient of the message
 * @param $account
 *   Sender of the message, defaults to the current user
 *
 * @return
 *   Either FALSE or a URL string
 *
 * @ingroup api
 */
function privatemsg_get_link($recipients, $account = array(), $subject = NULL) {
  if ($account == NULL) {
    global $user;
    $account = $user;
  }

  if (!is_array($recipients)) {
    $recipients = array($recipients);
  }

  if (!privatemsg_user_access('write privatemsg', $account) || $account->uid == 0) {
    return FALSE;
  }

  $validated = array();
  foreach ($recipients as $recipient) {
    if (!privatemsg_user_access('read privatemsg', $recipient)) {
      continue;
    }
    if (count(module_invoke_all('privatemsg_block_message', $account, array($recipient))) > 0) {
      continue;
    }
    $validated[] = $recipient->uid;
  }
  if (empty($validated)) {
    return FALSE;
  }
  $url = 'messages/new/'. implode(',', $validated);
  if (!is_null($subject)) {
    $url .= '/'. $subject;
  }
  return $url;
}

/**
 * Load a single message.
 *
 * @param $pmid
 *   Message id, pm.mid field
 * @param $account
 *   For which account the message should be loaded.
 *   Defaults to the current user.
 *
 * @ingroup api
 */
function _privatemsg_load($pmid, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = drupal_clone($user);
  }

  $query = _privatemsg_assemble_query('load', $pmid, $account);

  $result = db_query($query['query']);
  $message = db_fetch_array($result);
  $message['user'] = $account;
  // Load author of message.
  $message['author'] = user_load($message['author']);
  $returned = module_invoke_all('privatemsg_message_load', $message);
  if (!empty($returned)) {
    $message = array_merge_recursive($returned, $message);
  }
  return $message;
}

/**
 * Generates a query based on a query id.
 *
 * @param $query
 *   Either be a string ('some_id') or an array('group_name', 'query_id'),
 *   if a string is supplied, group_name defaults to 'privatemsg'.
 *
 * @return
 *    Array with the keys query and count. count can be used to count the
 *    elements which would be returned by query. count can be used together
 *    with pager_query().
 *
 * @ingroup sql
 */
function _privatemsg_assemble_query($query) {

  // Modules will be allowed to choose the prefix for the querybuilder, but if there is not one supplied, 'privatemsg' will be taken by default.
  if (is_array($query)) {
    $query_id = $query[0];
    $query_group = $query[1];
  }
  else {
    $query_id = $query;
    $query_group = 'privatemsg';
  }

  $SELECT = array();
  $INNER_JOIN = array();
  $WHERE = array();
  $GROUP_BY = array();
  $HAVING   = array();
  $ORDER_BY = array();
  $QUERY_ARGS = array('where' => array(), 'join' => array(), 'having' => array());
  $primary_table = '';

  $fragments = array(
    'select'      => $SELECT,
    'inner_join'  => $INNER_JOIN,
    'where'       => $WHERE,
    'group_by'    => $GROUP_BY,
    'having'      => $HAVING,
    'order_by'    => $ORDER_BY,
    'query_args'  => $QUERY_ARGS,
    'primary_table'  => $primary_table,
  );

  /**
   * Begin: dynamic arguments
   */
  $args = func_get_args();
  unset($args[0]);
  // we do the merge because we call call_user_func_array and not drupal_alter
  // this is necessary because otherwise we would not be able to use $args correctly (otherwise it doesnt unfold)
  $alterargs = array(&$fragments);
  $query_function = $query_group .'_sql_'. $query_id;
  if (!empty($args)) {
    $alterargs = array_merge($alterargs, $args);
  }
  /**
   * END: Dynamic arguments
   */
  if (!function_exists($query_function)) {
    drupal_set_message(t('Query function %function does not exist', array('%function' => $query_function)), 'error');
    return FALSE;
  }
  call_user_func_array($query_function, $alterargs);

  array_unshift($alterargs, $query_function);
  call_user_func_array('drupal_alter', $alterargs);

  $SELECT = $fragments['select'];
  $INNER_JOIN = $fragments['inner_join'];
  $WHERE = $fragments['where'];
  $GROUP_BY = $fragments['group_by'];
  $HAVING   = $fragments['having'];
  $ORDER_BY = $fragments['order_by'];
  $QUERY_ARGS = $fragments['query_args'];
  $primary_table = $fragments['primary_table'];

  // pgsql has a case sensitive LIKE - replace it with ILIKE. see http://drupal.org/node/462982
  if ($GLOBALS['db_type'] == 'pgsql') {
    $WHERE = str_replace('LIKE', 'ILIKE', $WHERE);
  }

  if (empty($primary_table)) {
    $primary_table = '{privatemsg} pm';
  }

  // Perform the whole query assembly only if we have something to select.
  if (!empty($SELECT)) {
    $str_select = implode(", ", $SELECT);
    $query = "SELECT {$str_select} FROM ". $primary_table;

    // Also build a count query which can be passed to pager_query to get a "page count" as that does not play well with queries including "GROUP BY".
    // In most cases,  "COUNT(*)" is enough to get the count query, but in queries involving a GROUP BY, we want a count of the number of groups we have, not the count of elements inside each group.
    // So we test if there is GROUP BY and if there is, count the number of distinct groups. If not, we go the normal wal and do a plain COUNT(*).
    if (!empty($GROUP_BY)) {
      // PostgreSQL does not support COUNT(sometextfield, someintfield), so I'm only using the first one
      // Works fine for thread_id/list but may generate an error when a more complex GROUP BY is used.
      $str_group_by_count = current($GROUP_BY);
      $count = "SELECT COUNT(DISTINCT {$str_group_by_count}) FROM ". $primary_table;
    }
    else {
      $count = "SELECT COUNT(*) FROM ". $primary_table;
    }

    if (!empty($INNER_JOIN)) {
      $str_inner_join = implode(' ', $INNER_JOIN);
      $query .= " {$str_inner_join}";
      $count .= " {$str_inner_join}";
    }
    if (!empty($WHERE)) {
      $str_where = '('. implode(') AND (', $WHERE) .')';
      $query .= " WHERE {$str_where}";
      $count .= " WHERE {$str_where}";
    }
    if (!empty($GROUP_BY)) {
      $str_group_by = ' GROUP BY '. implode(", ", $GROUP_BY) ;
      $query .= " {$str_group_by}";
    }
    if (!empty($HAVING)) {
      $str_having = '('. implode(') AND (', $HAVING) .')';
      $query .= " HAVING {$str_having}";
      // queries containing a HAVING break the count query on pgsql.
      // In this case, use the subquery method as outlined in http://drupal.org/node/303087#comment-1370752 .
      // The subquery method will work for all COUNT queries, but it is thought to be much slower, so we are only using it where other cross database approaches fail.
      $count = 'SELECT COUNT(*) FROM ('. $query .') as count';
    }
    if (!empty($ORDER_BY)) {
      $str_order_by = ' ORDER BY '. implode(", ", $ORDER_BY) ;
      $query .= " {$str_order_by}";
    }
    $QUERY_ARGS = array_merge($QUERY_ARGS['join'], $QUERY_ARGS['where'], $QUERY_ARGS['having']);
    if (!empty($QUERY_ARGS)) {
      _db_query_callback($QUERY_ARGS, TRUE);
      $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
      _db_query_callback($QUERY_ARGS, TRUE);
      $count = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $count);
    }
    return array('query' => $query, 'count' => $count);
  }
  return FALSE;
}

/**
 * Returns a form which handles and displays thread actions.
 *
 * Additional actions can be added with the privatemsg_thread_operations hook.
 * It is also possible to extend this form with additional buttons or other
 * elements, in that case, the definitions in the above hook need no label tag,
 * instead, the submit button key needs to match with the key of the operation.
 *
 * @see hook_privatemsg_thread_operations()
 *
 * @return
 *   The FAPI definitions for the thread action form.
 */
function _privatemsg_action_form() {
  $form = array(
      '#type'        => 'fieldset',
      '#title'       => t('Actions'),
      '#prefix'      => '<div class="container-inline">',
      '#suffix'      => '</div>',
      '#collapsible' => TRUE,
      '#collapsed'   => FALSE,
      '#weight'      => 15,
  );
  $form['delete'] = array(
      '#type'   => 'submit',
      '#value'  => t('Delete'),
  );
  // Display all operations which have a label.
  $options = array(0 => t('More actions...'));
  foreach (module_invoke_all('privatemsg_thread_operations') as $operation => $array) {
    if (isset($array['label'])) {
      $options[$operation] = $array['label'];
    }
  }
  $form['operation'] = array(
      '#type'          => 'select',
      '#options'       => $options,
      '#default_value' => 0,
      // Execute the submit button if a operation has been selected.
      '#attributes'    => array('onchange' => "$('#edit-submit').click()"),
  );
  $form['submit'] = array(
      '#type'       => 'submit',
      '#value'      => t('Execute'),
      '#submit'     => array('privatemsg_list_submit'),
      '#attributes' => array('class' => 'privatemsg-action-button'),
  );
  // JS for hiding the execute button(s)
  drupal_add_js(drupal_get_path('module', 'privatemsg') .'/privatemsg-list.js');
  return $form;
}

/**
 * Marks one or multiple threads as (un)read.
 *
 * @param $threads
 *   Array with thread id's or a single thread id.
 * @param $status
 *   Either PRIVATEMSG_READ or PRIVATEMSG_UNREAD, sets the new status.
 * @param $account
 *   User object for which the threads should be deleted, defaults to the current user.
 */
function privatemsg_thread_change_status($threads, $status, $account = NULL) {
  if (!is_array($threads)) {
    $threads = array($threads);
  }
  if (empty($account)) {
    global $user;
    $account = drupal_clone($user);
  }
  // Merge status and uid with the threads list. array_merge() will not overwrite/ignore thread_id 1.
  $params = array_merge(array($status, $account->uid), $threads);
  db_query('UPDATE {pm_index} SET is_new = %d WHERE uid = %d AND thread_id IN ('. db_placeholders($threads) .')', $params);

  if ($status == PRIVATEMSG_UNREAD) {
    drupal_set_message(t('Marked %count threads as unread.', array('%count' => count($threads))));
  }
  else {
    drupal_set_message(t('Marked %count threads as read.', array('%count' => count($threads))));
  }
}
/**
 * Returns a table header definition based on the submitted keys.
 *
 * Uses @link theming theme patterns @endlink to theme single headers.
 *
 * @param $has_posts
 *   TRUE when there is at least one row. Decides if the select all checkbox should be displayed.
 * @param $keys
 *   Array with the keys which are present in the query/should be displayed.
 * @return
 *   Array with header defintions for tablesort_sql and theme('table').
 */
function _privatemsg_list_headers($has_posts, $keys) {
  $select_header = $has_posts ? theme('table_select_header_cell') : '';
  $select_header['#weight'] = -50;

  // theme() doesn't include the theme file for patterns, we need to do it manually.
  include_once drupal_get_path('module', 'privatemsg') .'/privatemsg.theme.inc';

  $header = array($select_header);
  foreach ($keys as $key) {
    // First, try to load a specific theme for that header, if not present, use the default.
    if ($return = theme(array('privatemsg_list_header__'. $key, 'privatemsg_list_header'))) {
      // The default theme returns nothing, only store the value if we have something.
      $header[$key] = $return;
    }
  }
  return $header;
}

/**
 * Formats a row in the message list.
 *
 * Uses @link theming theme patterns @endlink to theme single fields.
 *
 * @param $thread
 *   Array with the row data returned by the database.
 * @return
 *   Row definition for use with theme('table')
 */
function _privatemsg_list_thread($thread) {
  $row = array('data' => array());

  if (!empty($thread['is_new'])) {
    // Set the css class in the tr tag.
    $row['class'] = 'privatemsg-unread';
  }
  foreach ($thread as $key => $data) {
    // First, try to load a specific theme for that field, if not present, use the default.
    if ($return = theme(array('privatemsg_list_field__'. $key, 'privatemsg_list_field'), $thread)) {
      // The default theme returns nothing, only store the value if we have something.
      $row['data'][$key] = $return;
    }
  }
  return $row;
}

/**
 * Menu callback for messages/undo/action.
 *
 * This function will test if an undo callback is stored in SESSION and execute it.
 */
function privatemsg_undo_action() {
  // Check if a undo callback for that user exists.
  if (isset($_SESSION['privatemsg']['undo callback']) && is_array($_SESSION['privatemsg']['undo callback'])) {
    $undo = $_SESSION['privatemsg']['undo callback'];
    // If the defined undo callback exists, execute it
    if (isset($undo['function']) && isset($undo['args'])) {
      call_user_func_array($undo['function'], $undo['args']);
    }
    // Return back to the site defined by the destination GET param.
    drupal_goto();
  }
}

/**
 * Process privatemsg_list form submissions.
 *
 * Execute the chosen action on the selected messages. This function is
 * based on node_admin_nodes_submit().
 */
function privatemsg_list_submit($form, &$form_state) {
  // Load all available operation definitions.
  $operations = module_invoke_all('privatemsg_thread_operations');

  // Default "default" operation, which won't do anything.
  $operation = array('callback' => 0);

  // Check if a valid operation has been submitted.
  if (isset($form_state['values']['operation']) && isset($operations[$form_state['values']['operation']])) {
    $operation = $operations[$form_state['values']['operation']];
  }

  // Load all keys where the value is the current op.
  $keys = array_keys($form_state['values'], $form_state['values']['op']);

  // The first one is op itself, we need to use the second.
  if (isset($keys[1]) && isset($operations[$keys[1]])) {
    $operation = $operations[$keys[1]];
  }

  // Filter out unchecked threads, this gives us an array of "checked" threads.
  $threads = array_filter($form_state['values']['threads']);

  // Only execute something if we have a valid callback and atleast one checked thread.
  if (!empty($operation['callback']) && !empty($threads)) {
    // Add in callback arguments if present.
    if (isset($operation['callback arguments'])) {
      $args = array_merge(array($threads), $operation['callback arguments']);
    }
    else {
      $args = array($threads);
    }
    // Execute the chosen action and pass the defined arguments.
    call_user_func_array($operation['callback'], $args);

    // Check if that operation has defined a undo callback
    if (isset($operation['undo callback']) && $undo_function = $operation['undo callback']) {
      // Add in callback arguments if present.
      if (isset($operation['undo callback arguments'])) {
        $undo_args = array_merge(array($threads), $operation['undo callback arguments']);
      }
      else {
        $undo_args = array($threads);
      }
      // Store the undo callback in the session and display a "Undo" link.
      // @todo: Provide a more flexible solution for such an undo action, operation defined string for example.
      $_SESSION['privatemsg']['undo callback'] = array('function' => $undo_function, 'args' => $undo_args);
      $undo = l(t('undone'), 'messages/undo/action', array('query' => drupal_get_destination()));

      drupal_set_message(t('The previous action can be !undo.', array('!undo' => $undo)));
    }
  }
}

/**
 * Delete or restore one or multiple threads.
 *
 * @param $threads
 *   Array with thread id's or a single thread id.
 * @param $delete
 *   Indicates if the threads should be deleted or restored. 1 => delete, 0 => restore.
 * @param $account
 *   User object for which the threads should be deleted, defaults to the current user.
 */
function privatemsg_thread_change_delete($threads, $delete, $account = NULL) {
  if (!is_array($threads)) {
    $threads = array($threads);
  }
  if (empty($account)) {
    global $user;
    $account = drupal_clone($user);
  }

  // Merge status and uid with the threads list. array_merge() will not overwrite/ignore thread_id 1.
  $params = array_merge(array($delete, $account->uid), $threads);

  // Load all messages of those threads including the deleted.
  $query = _privatemsg_assemble_query('messages', $threads, $account, TRUE);
  $result = db_query($query['query']);

  // Delete each message. We need to do that to trigger the delete hook.
  while ($row = db_fetch_array($result)) {
    privatemsg_message_change_delete($row['mid'], $delete, $account);
  }

  if ($delete) {
    drupal_set_message(t('Deleted %count threads.', array('%count' => count($threads))));
  }
  else {
    drupal_set_message(t('Restored %count threads.', array('%count' => count($threads))));
  }
}

/**
 * Implementation of hook_privatemsg_thread_operations().
 */
function privatemsg_privatemsg_thread_operations() {
  $operations = array(
    'mark as read' => array(
      'label' => t('Mark as read'),
      'callback' => 'privatemsg_thread_change_status',
      'callback arguments' => array('status' => PRIVATEMSG_READ),
      'undo callback' => 'privatemsg_thread_change_status',
      'undo callback arguments' => array('status' => PRIVATEMSG_UNREAD),
    ),
    'mark as unread' => array(
      'label' => t('Mark as unread'),
      'callback' => 'privatemsg_thread_change_status',
      'callback arguments' => array('status' => PRIVATEMSG_UNREAD),
      'undo callback' => 'privatemsg_thread_change_status',
      'undo callback arguments' => array('status' => PRIVATEMSG_READ),
    ),
    'delete' => array(
      'callback' => 'privatemsg_thread_change_delete',
      'callback arguments' => array('delete' => 1),
      'undo callback' => 'privatemsg_thread_change_delete',
      'undo callback arguments' => array('delete' => 0),
    ),
  );
  return $operations;
}
