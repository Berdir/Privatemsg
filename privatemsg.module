<?php
// $Id$

/**
 * @file
 * Allows users to send private messages to other users.
 */

/**
 * Status constant for read messages.
 */
define('PRIVATEMSG_READ', 0);
/**
 * Status constant for unread messages.
 */
define('PRIVATEMSG_UNREAD', 1);
/**
 * Show unlimited messages in a thread.
 */
define('PRIVATEMSG_UNLIMITED', 'unlimited');

/**
 * Implements hook_perm().
 */
function privatemsg_perm() {
  return array(
    'read privatemsg',
    'read all private messages',
    'allow disabling privatemsg',
    'administer privatemsg settings',
    'write privatemsg',
    'delete privatemsg',
  );
}

/**
 * Generate aray of user objects based on a string.
 *
 *
 * @param $userstring
 *   A string with user id, for example 1,2,4. Returned by the list query
 *
 * @return
 *   Array with user objects.
 */
function _privatemsg_generate_user_array($userstring, $slice = NULL) {
  static $user_cache = array();

  // Convert user uid list (uid1,uid2,uid3) into an array. If $slice is not NULL
  // pass that as argument to array_slice(). For example, -4 will only load the
  // last four users.
  // This is done to avoid loading user objects that are not displayed, for
  // obvious performance reasons.
  $users = explode(',', $userstring);
  if (!is_null($slice)) {
    $users = array_slice($users, $slice);
  }
  $participants = array();
  foreach ($users as $uid) {
    if (!array_key_exists($uid, $user_cache)) {
      $user_cache[$uid] = user_load($uid);
    }
    if (is_object($user_cache[$uid])) {
      $participants[$uid] = $user_cache[$uid];
    }
  }
  return $participants;
}

/**
 * Format an array of user objects.
 *
 * @param $part_array
 *   Array with user objects, for example the one returnd by
 *   _privatemsg_generate_user_array.
 *
 * @param $limit
 *   Limit the number of user objects which should be displayed.
 * @param $no_text
 *   When TRUE, don't display the Participants/From text.
 * @return
 *   String with formated user objects, like user1, user2.
 */
function _privatemsg_format_participants($part_array, $limit = NULL, $no_text = FALSE) {
  if (count($part_array) > 0) {
    $to = array();
    $limited = FALSE;
    foreach ($part_array as $account) {
      if (is_int($limit) && count($to) >= $limit) {
        $limited = TRUE;
        break;
      }
      $to[] = theme('username', $account);
    }

    $limit_string = '';
    if ($limited) {
      $limit_string = t(' and others');
    }


    if ($no_text) {
      return implode(', ', $to) . $limit_string;
    }

    $last = array_pop($to);
    if (count($to) == 0) { // Only one participant
      return t("From !last", array('!last' => $last));
    }
    else { // Multipe participants..
      $participants = implode(', ', $to);
      return t('Participants: !participants and !last', array('!participants' => $participants, '!last' => $last));
    }
  }
  return '';
}

/**
 * Implements hook_menu().
 */
function privatemsg_menu() {
  $items['messages'] = array(
    'title'            => 'Messages',
    'title callback'   => 'privatemsg_title_callback',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'list'),
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_NORMAL_ITEM,
  );
  $items['messages/list'] = array(
    'title'            => 'Messages',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'list'),
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'weight'           => -10,
  );
  $items['messages/view/%privatemsg_thread'] = array(
    'title'            => 'Read message',
    // Set the third argument to TRUE so that we can show access denied instead
    // of not found.
    'load arguments'   => array(NULL, NULL, TRUE),
    'page callback'    => 'privatemsg_view',
    'page arguments'   => array(2),
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_view_access',
    'access arguments' => array(2),
    'type'             => MENU_LOCAL_TASK,
    'weight'           => -5,
  );
  $items['messages/delete/%privatemsg_thread/%privatemsg_message'] = array(
    'title'            => 'Delete message',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_delete', 2, 3),
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('delete privatemsg'),
    'type'             => MENU_CALLBACK,
  );
  $items['messages/new'] = array(
    'title'            => 'Write new message',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_new', 2, 3, NULL),
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('write privatemsg'),
    'type'             => MENU_LOCAL_TASK,
    'weight'           => -3,
  );
  // Auto-completes available user names & removes duplicates.
  $items['messages/user-name-autocomplete'] = array(
    'page callback'    => 'privatemsg_user_name_autocomplete',
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('write privatemsg'),
    'type'             => MENU_CALLBACK,
    'weight'           => -10,
  );
  $items['admin/settings/messages'] = array(
    'title'            => 'Private messages',
    'description'      => 'Configure private messaging settings.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_admin_settings'),
    'file'             => 'privatemsg.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_NORMAL_ITEM,
  );
  $items['admin/settings/messages/default'] = array(
    'title'            => 'Private messages',
    'description'      => 'Configure private messaging settings.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_admin_settings'),
    'file'             => 'privatemsg.admin.inc',
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'weight'           => -10,
  );
  $items['messages/undo/action'] = array(
    'title'            => 'Private messages',
    'description'      => 'Undo last thread action',
    'page callback'    => 'privatemsg_undo_action',
    'file'             => 'privatemsg.pages.inc',
    'access arguments' => array('read privatemsg'),
    'type'             => MENU_CALLBACK,
  );
  $items['user/%/messages'] = array(
    'title' => 'Messages',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'list', 1),
    'file'             => 'privatemsg.pages.inc',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('read all private messages'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Privatemsg  wrapper for user_access.
 *
 * Never allows anonymous user access as that doesn't makes sense.
 *
 * @param $permission
 *   Permission string, defaults to read privatemsg
 *
 * @return
 *   TRUE if user has access, FALSE if not
 *
 * @ingroup api
 */
function privatemsg_user_access($permission = 'read privatemsg', $account = NULL) {
  static $disabled_displayed = FALSE;
  if ( $account === NULL ) {
    global $user;
    $account = $user;
  }
  if (!$account->uid) { // Disallow anonymous access, regardless of permissions
    return FALSE;
  }
  if (privatemsg_is_disabled($account) && ($permission == 'write privatemsg') ) {
    if (arg(0) == 'messages' && variable_get('privatemsg_display_disabled_message', TRUE) && !$disabled_displayed) {
      $disabled_displayed = TRUE;
      drupal_set_message(t('You have disabled Privatemsg and are not allowed to write messages. Go to your <a href="@settings_url">Account settings</a> to enable it again.', array('@settings_url' => url('user/' . $account->uid . '/edit'))), 'warning');
    }
    return FALSE;
  }
  if (!user_access($permission, $account)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Check access to the view messages page.
 *
 * Function to restrict the access of the view messages page to just the
 * messages/view/% pages and not to leave tabs artifact on other lower
 * level pages such as the messages/new/%.
 *
 * @param $thread
 *   A array containing all information about a specific thread, generated by
 *   privatemsg_thread_load().
 *
 * @ingroup api
 */
function privatemsg_view_access($thread) {
  // Do not allow access to threads without messages.
  if (empty($thread['messages'])) {
    // Count all messages, if there
    return FALSE;
  }
  if (privatemsg_user_access('read privatemsg') && arg(1) == 'view') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Checks the status of private messaging for provided user.
 *
 * @param user object to check
 * @return TRUE if user has disabled private messaging, FALSE otherwise
 */
function privatemsg_is_disabled(&$account) {

  if (!$account || !$account->uid) {
    return FALSE;
  }

  if (!isset($account->privatemsg_disabled)) {
    $account->privatemsg_disabled = (db_result(db_query('SELECT 1 FROM {pm_disable} WHERE uid = %d ', $account->uid)) <> 0);
  }

  return ($account->privatemsg_disabled);
}

/**
 * Load a thread with all the messages and participants.
 *
 * This function is called by the menu system through the %privatemsg_thread
 * wildcard.
 *
 * @param $thread_id
 *   Thread id, pmi.thread_id or pm.mid of the first message in that thread.
 * @param $account
 *   User object for which the thread should be loaded, defaults to
 *   the current user.
 * @param $start
 *   Message offset from the start of the thread.
 * @param $useAccessDenied
 *   Set to TRUE if the function should forward to the access denied page
 *   instead of not found. This is used by the menu system because that does
 *   load arguments before access checks are made. Defaults to FALSE.
 *
 * @return
 *   $thread object, with keys messages, participants, title and user. messages
 *   contains an array of messages, participants an array of user, subject the
 *   subject of the thread and user the user viewing the thread.
 *
 *   If no messages are found, or the thread_id is invalid, the function returns
 *   FALSE.

 * @ingroup api
 */
function privatemsg_thread_load($thread_id, $account = NULL, $start = NULL, $useAccessDenied = FALSE) {
  static $threads = array();
  if ((int)$thread_id > 0) {
    $thread = array('thread_id' => $thread_id);

    if (is_null($account)) {
      global $user;
      $account = drupal_clone($user);
    }

    if (!isset($threads[$account->uid])) {
      $threads[$account->uid] = array();
    }

    if (!array_key_exists($thread_id, $threads[$account->uid])) {
      // Load the list of participants.
      $query = _privatemsg_assemble_query('participants', $thread_id);
      $participants = db_query($query['query']);
      $thread['participants'] = array();
      while ($participant = db_fetch_object($participants)) {
        $thread['participants'][$participant->uid] = $participant;
      }
      $thread['read_all'] = FALSE;
      if (!array_key_exists($account->uid, $thread['participants']) && privatemsg_user_access('read all private messages', $account)) {
        $thread['read_all'] = TRUE;
      }

      // Load messages returned by the messages query with privatemsg_message_load_multiple().
      $query = _privatemsg_assemble_query('messages', array($thread_id), $thread['read_all'] ? NULL : $account);
      $thread['message_count'] = $thread['to'] = db_result(db_query($query['count']));
      $thread['from'] = 1;
      // Check if we need to limit the messages.
      $max_amount = variable_get('privatemsg_view_max_amount', 20);

      // If there is no start value, select based on get params.
      if (is_null($start)) {
        if (isset($_GET['start']) && $_GET['start'] < $thread['message_count']) {
          $start = $_GET['start'];
        }
        elseif (!variable_get('privatemsg_view_use_max_as_default', FALSE) && $max_amount == PRIVATEMSG_UNLIMITED) {
          $start = PRIVATEMSG_UNLIMITED;
        }
        else {
          $start = $thread['message_count'] - (variable_get('privatemsg_view_use_max_as_default', FALSE) ? variable_get('privatemsg_view_default_amount', 10) : $max_amount);
        }
      }

      if ($start != PRIVATEMSG_UNLIMITED) {
        if ($max_amount == PRIVATEMSG_UNLIMITED) {
          $last_page = 0;
          $max_amount = $thread['message_count'];
        }
        else {
          // Calculate the number of messages on the "last" page to avoid
          // message overlap.
          // Note - the last page lists the earliest messages, not the latest.
          $paging_count = variable_get('privatemsg_view_use_max_as_default', FALSE) ? $thread['message_count'] - variable_get('privatemsg_view_default_amount', 10) : $thread['message_count'];
          $last_page = $paging_count % $max_amount;
        }

        // Sanity check - we cannot start from a negative number.
        if ($start < 0) {
          $start = 0;
        }
        $thread['start'] = $start;

        //If there are newer messages on the page, show pager link allowing to go to the newer messages.
        if (($start + $max_amount + 1) < $thread['message_count']) {
          $thread['to'] = $start + $max_amount;
          $thread['newer_start'] = $start + $max_amount;
        }
        if ($start - $max_amount >= 0) {
          $thread['older_start'] = $start - $max_amount;
        }
        elseif ($start > 0) {
          $thread['older_start'] = 0;
        }

        // Do not show messages on the last page that would show on the page
        // before. This will only work when using the visual pager.
        if ($start < $last_page && $max_amount != PRIVATEMSG_UNLIMITED && $max_amount < $thread['message_count']) {
          unset($thread['older_start']);
          $thread['to'] = $thread['newer_start'] = $max_amount = $last_page;
          // Start from the first message - this is a specific hack to make sure
          // the message display has sane paging on the last page.
          $start = 0;
        }
        // Visual counts start from 1 instead of zero, so plus one.
        $thread['from'] = $start + 1;
        $conversation = db_query_range($query['query'], $start, $max_amount);
      }
      else {
        $conversation = db_query($query['query']);
      }
      $mids = array();
      while ($result = db_fetch_array($conversation)) {
        $mids[] = $result['mid'];
      }
      // Load messages returned by the messages query.
      $thread['messages'] = privatemsg_message_load_multiple($mids, $thread['read_all'] ? NULL : $account);

      // If there are no messages, don't allow access to the thread.
      if (empty($thread['messages'])) {
        if ($useAccessDenied) {
          // Generate new query with read all to see if the thread does exist.
          $query = _privatemsg_assemble_query('messages', array($thread_id), NULL);
          $exists = db_result(db_query($query['count']));
          if (!$exists) {
            // Thread does not exist, display 404.
            $thread = FALSE;
          }
        }
        else {
          $thread = FALSE;
        }
      }
      else {
        // General data, assume subject is the same for all messages of that thread.
        $thread['user'] = $account;
        $message = current($thread['messages']);
        $thread['subject'] = $message['subject'];
      }
      $threads[$account->uid][$thread_id] = $thread;
    }

    return $threads[$account->uid][$thread_id];
  }
  return FALSE;
}

function private_message_view_options() {
  $options = module_invoke_all('privatemsg_view_template');
  return $options;
}

/**
 * Implements hook_privatemsg_view_template().
 *
 * Allows modules to define different message view template.
 *
 * This hook returns information about available themes for privatemsg viewing.
 *
 * array(
 *  'machine_template_name' => 'Human readable template name',
 *  'machine_template_name_2' => 'Human readable template name 2'
 * };
 */
function privatemsg_privatemsg_view_template() {
  return array(
    'privatemsg-view' => 'Default view',
  );
}

/**
 * Implements hook_cron().
 *
 * If the flush feature is enabled, a given amount of deleted messages that are
 * old enough are flushed.
 */
function privatemsg_cron() {
  if (variable_get('privatemsg_flush_enabled', FALSE)) {
    $query = _privatemsg_assemble_query('deleted', variable_get('privatemsg_flush_days', 30));
    $result = db_query($query['query']);

    $flushed = 0;
    while (($row = db_fetch_array($result)) && ($flushed < variable_get('privatemsg_flush_max', 200))) {
      $message = privatemsg_message_load($row['mid']);
      module_invoke_all('privatemsg_message_flush', $message);

      // Delete recipients of the message.
      db_query('DELETE FROM {pm_index} WHERE mid = %d', $row['mid']);
      // Delete message itself.
      db_query('DELETE FROM {pm_message} WHERE mid = %d', $row['mid']);
      $flushed++;
    }
  }
}

function privatemsg_theme() {
  return array(
    'privatemsg_view'    => array(
      'arguments'        => array('message' => NULL),
      'template'         => variable_get('private_message_view_template', 'privatemsg-view'), // 'privatemsg',
    ),
    'privatemsg_from'    => array(
      'arguments'        => array('author' => NULL),
      'template'         => 'privatemsg-from',
    ),
    'privatemsg_recipients' => array(
      'arguments'        => array('message' => NULL),
      'template'         => 'privatemsg-recipients',
    ),
    'privatemsg_between' => array(
      'arguments'        => array('recipients' => NULL),
      'template'         => 'privatemsg-between',
    ),
    'privatemsg_list'    => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'arguments'        => array('form'),
    ),
    // Define pattern for header/field templates. The theme system will register all
    // theme functions that start with the defined pattern.
    'privatemsg_list_header'  => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'pattern'               => 'privatemsg_list_header__',
      'arguments'             => array(),
    ),
    'privatemsg_list_field'   => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'pattern'               => 'privatemsg_list_field__',
      'arguments'             => array('thread'),
    ),
    'privatemsg_new_block'  => array(
      'file'                  => 'privatemsg.theme.inc',
      'path'                  => drupal_get_path('module', 'privatemsg'),
      'arguments'             => array('count'),
    ),
  );
}

function privatemsg_preprocess_privatemsg_view(&$vars) {
//  drupal_set_message('<pre>'. print_r($vars,1 ) . '</pre>');

  $message = $vars['message'];
  $vars['mid'] = isset($message['mid']) ? $message['mid'] : NULL;
  $vars['thread_id'] = isset($message['thread_id']) ? $message['thread_id'] : NULL;
  $vars['author_picture'] = theme('user_picture', $message['author']);
  $vars['author_name_link'] = theme('username', $message['author']);
  /**
   * @todo perhaps make this timestamp configurable via admin UI?
   */
  $vars['message_timestamp'] = format_date($message['timestamp'], 'small');
  $vars['message_body'] = check_markup($message['body'], $message['format'], FALSE);
  if (isset($vars['mid']) && isset($vars['thread_id']) && privatemsg_user_access('delete privatemsg')) {
    $vars['message_actions'][] = array('title' => t('Delete message'), 'href' => 'messages/delete/' . $vars['thread_id'] . '/' . $vars['mid']);
  }
  $vars['message_anchors'][] = 'privatemsg-mid-' . $vars['mid'];
  if (!empty($message['is_new'])) {
    $vars['message_anchors'][] = 'new';
    $vars['new'] = drupal_ucfirst(t('new'));
  }

  // call hook_privatemsg_message_view_alter
  drupal_alter('privatemsg_message_view', $vars);

  $vars['message_actions'] = !empty($vars['message_actions']) ? theme('links', $vars['message_actions'], array('class' => 'privatemsg-message-actions')) : '';

  $vars['anchors'] = '';
  foreach ($vars['message_anchors'] as $anchor) {
    $vars['anchors'] .= '<a name="' . $anchor . '"></a>';
  }
}

function privatemsg_preprocess_privatemsg_recipients(&$vars) {
  $vars['participants'] = ''; // assign a default empty value
  if (isset($vars['message']['participants'])) {
    $vars['participants'] = _privatemsg_format_participants($vars['message']['participants']);
  }
}

/**
 * Changes the read/new status of a single message.
 *
 * @param $pmid
 *   Message id
 * @param $status
 *   Either PRIVATEMSG_READ or PRIVATEMSG_UNREAD
 * @param $account
 *   User object, defaults to the current user
 */
function privatemsg_message_change_status($pmid, $status, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  $query = "UPDATE {pm_index} SET is_new = %d WHERE mid = %d AND uid = %d";
  db_query($query, $status, $pmid, $account->uid);
}

/**
 * Return number of unread messages for an account.
 *
 * @param $account
 *   Specifiy the user for which the unread count should be loaded.
 *
 * @ingroup api
 */
function privatemsg_unread_count($account = NULL) {
  static $counts = array();
  if (!$account || $account->uid == 0) {
    global $user;
    $account = $user;
  }
  if ( !isset($counts[$account->uid])) {
    $query = _privatemsg_assemble_query('unread_count', $account);
    $counts[$account->uid] = db_result(db_query($query['query']));
  }
  return $counts[$account->uid];
}

/**
 * Load all participants of a thread, optionally without author.
 *
 * @param $thread_id
 *   Thread ID for wich the participants should be loaded.
 */
function _privatemsg_load_thread_participants($thread_id) {
  $query = _privatemsg_assemble_query('participants', $thread_id);
  $result = db_query($query['query']);
  $participants = array();
  while ($uid = db_fetch_object($result)) {
    if (($recipient = user_load($uid->uid))) {
      $participants[$recipient->uid] = $recipient;
    }
  }
  return $participants;
}

/**
 * Extract the valid usernames of a string and loads them.
 *
 * This function is used to parse a string supplied by a username autocomplete
 * field and load all user objects.
 *
 * @param $string
 *   A string in the form "usernameA, usernameB, ...".
 * @return
 *   Array, first element is an array of loaded user objects, second an array
 *   with invalid names.
 */
function _privatemsg_parse_userstring($input) {
  if (is_string($input)) {
    $input = explode(',', $input);
  }

  // Start working through the input array.
  $invalid = array();
  $recipients = array();
  foreach ($input as $string) {
    $string = trim($string);
    if (!empty($string)) { // We don't care about white space names.

      // First, check if another module is able to resolve the string into an
      // user object.
      foreach (module_implements('privatemsg_name_lookup') as $module) {
        $function = $module . '_privatemsg_name_lookup';
        if (($recipient = $function($string)) && is_object($recipient)) {
          // If there is a match, continue with the next input string.
          $recipients[$recipient->uid] = $recipient;
          continue 2;
        }
      }
      // Fall back to the default username lookup.
      if (!$error = module_invoke('user', 'validate_name', $string)) {
        // String is a valid username, look it up.
        if ($recipient = user_load(array('name' => $string))) {
          $recipients[$recipient->uid] = $recipient;
          continue;
        }
      }
      $invalid[$string] = $string;
    }
  }

  return array($recipients, $invalid);
}

/**
 * @addtogroup sql
 * @{
 */

/**
 * Query definition to load a list of threads.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $account
 *   User object for which the messages are being loaded.
 * @param $argument
 *   String argument which can be used in the query builder to modify the
 *   thread listing.
 */

function privatemsg_sql_list(&$fragments, $account, $argument = 'list') {
  $fragments['primary_table'] = '{pm_message} pm';

  // Load enabled columns.
  $fields = array_filter(variable_get('privatemsg_display_fields', array('participants')));

  // Required columns.
  $fragments['select'][]      = 'pmi.thread_id';
  // We have to use MIN as the subject might not be the same in some threads.
  // MIN() does not have a useful meaning except that it helps to correctly
  // aggregate the thread on PostgreSQL.
  $fragments['select'][]      = 'MIN(pm.subject) as subject';
  $fragments['select'][]      = 'MAX(pm.timestamp) as last_updated';
  // We use SUM so that we can count the number of unread messages.
  $fragments['select'][]      = 'SUM(pmi.is_new) as is_new';

  // Select number of messages in the thread if the count is
  // set to be displayed.
  if (in_array('count', $fields)) {
    $fragments['select'][]      = 'COUNT(distinct pmi.mid) as count';
  }
  if (in_array('participants', $fields)) {
    // Query for a string with uid's, for example "1,6,7".
    // @todo: Replace this with a single query similiar to the tag list.
    if ($GLOBALS['db_type'] == 'pgsql') {
      // PostgreSQL does not know GROUP_CONCAT, so a subquery is required.
      $fragments['select'][]      = "array_to_string(array(SELECT DISTINCT textin(int4out(pmia.uid))
                                                            FROM {pm_index} pmia
                                                            WHERE pmia.thread_id = pmi.thread_id), ',') AS participants";
    }
    else {
      $fragments['select'][]      = '(SELECT GROUP_CONCAT(DISTINCT pmia.uid SEPARATOR ",")
                                                            FROM {pm_index} pmia
                                                            WHERE pmia.thread_id = pmi.thread_id) AS participants';
    }
  }
  if (in_array('thread_started', $fields)) {
    $fragments['select'][]      = 'MIN(pm.timestamp) as thread_started';
  }

  $fragments['inner_join'][]  = 'INNER JOIN {pm_index} pmi ON pm.mid = pmi.mid';

  // Only load undeleted messages of the current user and group by thread.
  $fragments['where'][]       = 'pmi.uid = %d';
  $fragments['query_args']['where'][]  = $account->uid;
  $fragments['where'][]       = 'pmi.deleted = 0';
  $fragments['group_by'][]    = 'pmi.thread_id';

  // tablesort_sql() generates a ORDER BY string. However, the "ORDER BY " part
  // is not needed and added by the query builder. Discard the first 9
  // characters of the string.
  $order_by = drupal_substr(tablesort_sql(_privatemsg_list_headers(FALSE, array_merge(array('subject', 'last_updated'), $fields))), 9);
  $fragments['order_by'][]  = $order_by;
}

/**
 * Query function for loading a single or multiple messages.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $pmids
 *   Array of pmids.
 * @param $account
 *   Account for which the messages should be loaded.
 */
function privatemsg_sql_load(&$fragments, $pmids, $account = NULL) {
  $fragments['primary_table'] = '{pm_message} pm';

  $fragments['select'][]      = "pm.mid";
  $fragments['select'][]      = "pm.author";
  $fragments['select'][]      = "pm.subject";
  $fragments['select'][]      = "pm.body";
  $fragments['select'][]      = "pm.timestamp";
  $fragments['select'][]      = "pm.format";
  $fragments['select'][]      = "pmi.is_new";
  $fragments['select'][]      = "pmi.thread_id";

  $fragments['inner_join'][]  = 'INNER JOIN {pm_index} pmi ON pm.mid = pmi.mid';
  // Use IN() to load multiple messages at the same time.
  $fragments['where'][]       = 'pmi.mid IN (' . db_placeholders($pmids) . ')';
  $fragments['query_args']['where']  += $pmids;
  if ($account) {
    $fragments['where'][]       = 'pmi.uid = %d';
    $fragments['query_args']['where'][]  = $account->uid;
  }
  $fragments['order_by'][] = 'pm.timestamp ASC';
  $fragments['order_by'][] = 'pm.mid ASC';
}

/**
 * Query definition to load messages of one or multiple threads.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $threads
 *   Array with one or multiple thread id's.
 * @param $account
 *   User object for which the messages are being loaded.
 * @param $load_all
 *   Deleted messages are only loaded if this is set to TRUE.
 */
function privatemsg_sql_messages(&$fragments, $threads, $account = NULL, $load_all = FALSE) {
  $fragments['primary_table'] = '{pm_index} pmi';

  $fragments['select'][]      = 'pmi.mid';
  $fragments['where'][]       = 'pmi.thread_id IN ('. db_placeholders($threads) .')';
  $fragments['query_args']['where']   += $threads;
  $fragments['inner_join'][]  = 'INNER JOIN {pm_message} pm ON (pm.mid = pmi.mid)';
  if ($account) {
    // Only load the user's messages.
    $fragments['where'][]     = 'pmi.uid = %d';
    $fragments['query_args']['where'][]  = $account->uid;
  }
  if (!$load_all) {
    // Also load deleted messages when requested.
    $fragments['where'][]     = 'pmi.deleted = 0';
  }
  // Only load each mid once.
  $fragments['group_by'][]    = 'pmi.mid';
  $fragments['group_by'][]    = 'pm.timestamp';

  // Order by timestamp first.
  $fragments['order_by'][]    = 'pm.timestamp ASC';
  // If there are multiple inserts during the same second (tests, for example)
  // sort by mid second to have them in the same order as they were saved.
  $fragments['order_by'][]    = 'pmi.mid ASC';

}

/**
 * Load all participants of a thread.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $thread_id
 *   Thread id from which the participants should be loaded.
 */
function privatemsg_sql_participants(&$fragments, $thread_id) {
  $fragments['primary_table'] = '{pm_index} pmi';

  // Only load each participant once since they are listed as recipient for
  // every message of that thread.
  $fragments['select'][]      = 'DISTINCT(pmi.uid) AS uid';
  $fragments['select'][]      = 'u.name AS name';

  $fragments['inner_join'][]  = 'INNER JOIN {users} u ON (u.uid = pmi.uid)';
  $fragments['where'][]       = 'pmi.thread_id = %d';
  $fragments['query_args']['where'][]  = $thread_id;
}

/**
 * Query definition to count unread messages.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $account
 *   User object for which the messages are being counted.
 */
function privatemsg_sql_unread_count(&$fragments, $account) {
  $fragments['primary_table'] = '{pm_index} pmi';

  $fragments['select'][]      = 'COUNT(DISTINCT thread_id) as unread_count';

  // Only count new messages that have not been deleted.
  $fragments['where'][]       = 'pmi.deleted = 0';
  $fragments['where'][]       = 'pmi.is_new = 1';
  $fragments['where'][]       = 'pmi.uid = %d';
  $fragments['query_args']['where'][]  = $account->uid;
}

/**
 * Query definition to search for username autocomplete suggestions.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $search
 *   Which search string is currently searched for.
 * @param $names
 *   Array of names not to be used as suggestions.
 */
function privatemsg_sql_autocomplete(&$fragments, $search, $names) {
  $fragments['primary_table'] = '{users} u';
  $fragments['select'][] = 'u.name';

  // exclude users that have disabled private messaging
  $fragments['where'][] = "NOT EXISTS (SELECT 1 FROM {pm_disable} pd WHERE pd.uid=u.uid)";

  // Escape the % to get it through the placeholder replacement.
  $fragments['where'][] = "u.name LIKE '%s'";
  $fragments['query_args']['where'][] = $search .'%%';
  if (!empty($names)) {
    // If there are already names selected, exclude them from the suggestions.
    $fragments['where'][] = "u.name NOT IN (". db_placeholders($names, 'text') .")";
    $fragments['query_args']['where'] += $names;
  }
  // Only load active users and sort them by name.
  $fragments['where'][] = 'u.status <> 0';
  $fragments['order_by'][] = 'u.name ASC';
}

/**
 * Query Builder function to load all messages that should be flushed.
 *
 * @param $fragments
 *   Query fragments array.
 * @param $days
 *   Select messages older than x days.
 */
function privatemsg_sql_deleted(&$fragments, $days) {
  $fragments['primary_table'] = '{pm_message} pm';

  $fragments['select'][] = 'pm.mid';
  // The lowest value is higher than 0 if all recipients have deleted a message.
  $fragments['select'][] = 'MIN(pmi.deleted) as is_deleted';
  // The time the most recent deletion happened.
  $fragments['select'][] = 'MAX(pmi.deleted) as last_deleted';

  $fragments['inner_join'][] = 'INNER JOIN {pm_index} pmi ON (pmi.mid = pm.mid)';

  $fragments['group_by'][] = 'pm.mid';

  // Ignore messages that have not been deleted by all users.
  $fragments['having'][] = 'MIN(pmi.deleted) > 0';

  // Only select messages that have been deleted more than n days ago.
  $fragments['having'][] = 'MAX(pmi.deleted) < %d';
  $fragments['query_args']['having'][] = time() - $days * 86400;
}

/**
 * @}
 */

function privatemsg_user($op, &$edit, &$account, $category = NULL) {
  global $user;

  switch ($op) {
    case 'form':
      // We have to use user_acces() because privatemsg_user_access() would
      // return FALSE when privatemsg is disabled.
      if ($category == 'account' && user_access('write privatemsg') && user_access('allow disabling privatemsg')) {
        $form['privatemsg'] = array(
          '#type' => 'fieldset',
          '#title' => t('Privatemsg settings'),
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
          '#weight' => 10,
        );

        $form['privatemsg']['pm_enable'] = array(
          '#type' => 'checkbox',
          '#title' => t('Enable Private Messaging'),
          '#default_value' => (int) !privatemsg_is_disabled($account),
          '#description' => t('Disabling private messages prevents you from sending or receiving messages from other users.'),
        );
        return $form;
      }

    case 'submit':
      if ($category == 'account' && isset($edit['pm_enable']) && user_access('write privatemsg') && user_access('allow disabling privatemsg')) {
        $current = privatemsg_is_disabled($account);
        $disabled = (!$edit['pm_enable']);
        unset($edit['pm_enable']);

        $account->privatemsg_disabled = $disabled;

        // only perform the save if the value has changed
        if ($current != $disabled) {
          if ($disabled) {
            db_query('INSERT into {pm_disable} values (%d)', $account->uid);
          }
          else {
            db_query('DELETE from {pm_disable} where uid = %d', $account->uid);
          }
        }
      }
      break;

    case 'view':
      if (($url = privatemsg_get_link(array($account))) && variable_get('privatemsg_display_profile_links', 1)) {
        $account->content['privatemsg_send_new_message'] = array(
          '#type'   => 'markup',
          '#value'  => l(t('Send this user a message'), $url, array('query' => drupal_get_destination(), 'attributes' => array('title' => t('Send this user a message')))),
          '#weight' => 10,
        );
      }
      break;
    case 'login':
      if (variable_get('privatemsg_display_loginmessage', TRUE) && privatemsg_user_access()) {
        $count = privatemsg_unread_count();
        if ($count) {
          drupal_set_message(format_plural($count, 'You have <a href="@messages">1 unread message</a>.', 'You have <a href="@messages">@count unread messages</a>', array('@messages' => url('messages'))));
        }
      }
      break;
    case 'delete':

      // Load all mids of the messages the user wrote.
      $result = db_query("SELECT mid FROM {pm_message} WHERE author = %d", $account->uid);
      $mids = array();
      while ($row = db_fetch_array($result)) {
        $mids[] = $row['mid'];
      }

      // Delete messages the user wrote.
      db_query('DELETE FROM {pm_message} WHERE author = %d', $account->uid);

      if (!empty($mids)) {
        // Delete recipient entries in {pm_index} of the messages the user wrote.
        db_query('DELETE FROM {pm_index} WHERE mid IN (' . db_placeholders($mids) . ')', $mids);
      }

      // Delete recipient entries of that user.
      db_query('DELETE FROM {pm_index} WHERE uid = %d', $account->uid);

      // DELETE any disable flag for user.
      db_query('DELETE from {pm_disable} where uid=%d', $account->uid);
      break;
  }
}

function privatemsg_block($op = 'list', $delta = 0, $edit = array()) {
  if ('list' == $op) {
    $blocks = array();
    $blocks['privatemsg-menu'] = array(
      'info' => t('Privatemsg links'),
      'cache' => BLOCK_NO_CACHE,
    );
    $blocks['privatemsg-new'] = array(
      'info' => t('New message indication'),
      'cache' => BLOCK_NO_CACHE,
    );

    return $blocks;
  }
  elseif ('view' == $op) {
    $block = array();
    switch ($delta) {
      case 'privatemsg-menu':
        $block = _privatemsg_block_menu();
        break;
      case 'privatemsg-new':
        $block = _privatemsg_block_new();
        break;
    }
    return $block;
  }
}

function privatemsg_title_callback($title = NULL) {
  $count = privatemsg_unread_count();

  if ($count > 0) {
    return format_plural($count, 'Messages (1 new)', 'Messages (@count new)');
  }
  return t('Messages');
}


function _privatemsg_block_new() {
  $block = array();

  if (!privatemsg_user_access()) {
    return $block;
  }

  $count = privatemsg_unread_count();
  if ($count) {
    $block = array(
      'subject' => format_plural($count, 'New message', 'New messages'),
      'content' => theme('privatemsg_new_block', $count),
    );
    return $block;
  }
  return array();
}

function _privatemsg_block_menu() {
  $block = array();

  $links = array();
  if (privatemsg_user_access('write privatemsg')) {
    $links[] = l(t('Write new message'), 'messages/new', array('attributes' => array('title' => t('Write new message'))));
  }
  if (privatemsg_user_access('read privatemsg') || privatemsg_user_access('read all private messages') ) {
    $links[] = l(privatemsg_title_callback(), 'messages');
  }
  if ( count( $links ) ) {
    $block = array(
      'subject' => t('Private messages'),
      'content' => theme('item_list', $links),
    );
  }
  return $block;
}

/**
 * Delete or restore a message.
 *
 * @param $pmid
 *   Message id, pm.mid field.
 * @param $delete
 *   Either deletes or restores the thread (1 => delete, 0 => restore)
 * @param $account
 *   User acccount for which the delete action should be carried out - Set to
 *   NULL to delete for all users.
 *
 * @ingroup api
 */
function privatemsg_message_change_delete($pmid, $delete, $account = NULL) {
  $delete_value = 0;
  if ($delete == TRUE) {
    $delete_value = time();
  }

  if ($account) {
    db_query('UPDATE {pm_index} SET deleted = %d WHERE mid = %d AND uid = %d', $delete_value, $pmid, $account->uid);
  }
  else {
    // Mark deleted for all users.
    db_query('UPDATE {pm_index} SET deleted = %d WHERE mid = %d', $delete_value, $pmid);
  }
}

/**
 * Send a new message.
 *
 * This functions does send a message in a new thread.
 * Example:
 * @code
 * privatemsg_new_thread(array(user_load(5)), 'The subject', 'The body text');
 * @endcode
 *
 * @param $recipients
 *   Array of recipients (user objects)
 * @param $subject
 *   The subject of the new message
 * @param $body
 *   The body text of the new message
 * @param $options
 *   Additional options, possible keys:
 *     author => User object of the author
 *     timestamp => Time when the message was sent
 *
 * @return
 *   An array with a key success. If TRUE, it also contains a key 'message' with
 *   the created $message array, the same that is passed to the insert hook.
 *   If FALSE, it contains a key 'messages'. This key contains an array where
 *   the key is the error type (error, warning, notice) and an array with
 *   messages of that type.
 *
 *   It is theoretically possible for success to be TRUE and message to be
 *   FALSE. For example if one of the privatemsg database tables become
 *   corrupted. When testing for success of message being sent it is always
 *   best to see if ['message'] is not FALSE as well as ['success'] is TRUE.
 *
 *   Example:
 *   @code
 *   array('error' => array('A error message'))
 *   @endcode
 *
 * @ingroup api
 */
function privatemsg_new_thread($recipients, $subject, $body = NULL, $options = array()) {
  global $user;
  $author = drupal_clone($user);

  $message = array();
  $message['subject'] = $subject;
  $message['body'] = $body;
  // Make sure that recipients are keyed by user id and are not added
  // multiple times.
  foreach ($recipients as $recipient) {
    $message['recipients'][$recipient->uid] = $recipient;
  }

  // Set custom options, if any.
  if (!empty($options)) {
    $message += $options;
  }
  // Apply defaults - this will not overwrite existing keys.
  $message += array(
    'author' => $author,
    'timestamp' => time(),
    'format' => filter_resolve_format(FILTER_FORMAT_DEFAULT),
  );

  $validated = _privatemsg_validate_message($message);
  if ($validated['success']) {
    $validated['message'] = _privatemsg_send($message);
  }

  return $validated;
}

/**
 * Send a reply message
 *
 * This functions replies on an existing thread.
 *
 * @param $thread_id
 *   Thread id
 * @param $body
 *   The body text of the new message
 * @param $options
 *   Additional options, possible keys:
 *     author => User object of the author
 *     timestamp => Time when the message was sent
 *
 * @return
 *   An array with a key success and messages. This key contains an array where
 *   the key is the error type (error, warning, notice) and an array with
 *   messages of that type.. If success is TRUE, it also contains a key $message
 *   with the created $message array, the same that is passed to
 *   hook_privatemsg_message_insert().
 *
 *   It is theoretically possible for success to be TRUE and message to be
 *   FALSE. For example if one of the privatemsg database tables become
 *   corrupted. When testing for success of message being sent it is always
 *   best to see if ['message'] is not FALSE as well as ['success'] is TRUE.
 *
 *   Example messages values:
 *   @code
 *   array('error' => array('A error message'))
 *   @endcode
 *
 * @ingroup api
 */
function privatemsg_reply($thread_id, $body, $options = array()) {
  global $user;
  $author = drupal_clone($user);

  $message = array();
  $message['body'] = $body;

  // set custom options, if any
  if (!empty($options)) {
    $message += $options;
  }
  // apply defaults
  $message += array(
    'author' => $author,
    'timestamp' => time(),
    'format' => filter_resolve_format(FILTER_FORMAT_DEFAULT),
  );

  // We don't know the subject and the recipients, so we need to load them..
  // thread_id == mid on the first message of the thread
  $first_message = privatemsg_message_load($thread_id, $message['author']);
  if (!$first_message) {
    return array(t('Thread %thread_id not found, unable to answer', array('%thread_id' => $thread_id)));
  }

  $message['thread_id'] = $thread_id;
  // Load participants.
  $message['recipients'] = _privatemsg_load_thread_participants($thread_id);
  // Remove author.
  if (isset($message['recipients'][$message['author']->uid]) && count($message['recipients']) > 1) {
    unset($message['recipients'][$message['author']->uid]);
  }
  $message['subject'] = $first_message['subject'];

  $validated = _privatemsg_validate_message($message);
  if ($validated['success']) {
    $validated['message'] = _privatemsg_send($message);
  }
  return $validated;
}

function _privatemsg_validate_message(&$message, $form = FALSE) {
  $messages = array('error' => array(), 'warning' => array());
  if (!privatemsg_user_access('write privatemsg', $message['author'])) {
    // no need to do further checks in this case...
    if ($form) {
      form_set_error('author', t('User @user is not allowed to write messages', array('@user' => $message['author']->name)));
      return array(
        'success'  => FALSE,
        'messages'   => $messages,
      );
    }
    else {
      $messages['error'][] = t('User @user is not allowed to write messages', array('@user' => $message['author']->name));
      return array(
         'success'  => FALSE,
         'messages'   => $messages,
      );
    }
  }

  if (empty($message['subject'])) {
    if ($form) {
      form_set_error('subject', t('Disallowed to send a message without subject'));
    }
    else {
      $messages['error'][] = t('Disallowed to send a message without subject');
    }
  }

  // Don't allow replies without a body.
  if (!empty($message['thread_id']) && empty($message['body'])) {
    if ($form) {
      form_set_error('body', t('Disallowed to send reply without a message.'));
    }
    else {
      $messages['error'][] = t('Disallowed to send reply without a message.');
    }
  }
  // Check if an allowed format is used. global $user needs to be changed since
  // it is not possible to do the check for a specific user.
  global $user;
  $original_user = drupal_clone($user);
  session_save_session(FALSE);
  $user = $message['author'];

  if (!filter_access($message['format'])) {
    if ($form) {
      form_set_error('format', t('You are not allowed to use the specified input format.'));
    }
    else {
      $messages['error'][] = t('User @user is not allowed to use the specified input format.', array('@user' => $message['author']->name));
    }
  }

  $user = $original_user;
  session_save_session(TRUE);

  if (empty($message['recipients']) || !is_array($message['recipients'])) {
    if ($form) {
      form_set_error('to', t('Disallowed to send a message without at least one valid recipient'));
    }
    else {
      $messages['error'][] = t('Disallowed to send a message without at least one valid recipient');
    }
  }

  if (!empty($message['recipients']) && is_array($message['recipients'])) {
    foreach (module_invoke_all('privatemsg_block_message', $message['author'], $message['recipients']) as $blocked) {
      unset($message['recipients'][$blocked['uid']]);
      if ($form) {
        drupal_set_message($blocked['message'], 'warning');
      }
      else {
        $messages['warning'][] = $blocked['message'];
      }
    }
  }

  // Check again, give another error message if all recipients are blocked
  if (empty($message['recipients'])) {
    if ($form) {
      form_set_error('to', t('Disallowed to send message because all recipients are blocked'));
    }
    else {
      $messages['error'][] = t('Disallowed to send message because all recipients are blocked');
    }
  }

  $messages += module_invoke_all('privatemsg_message_validate', $message, $form);
  // Check if there are errors in $messages or if $form is TRUE, there are form errors.
  $success = empty($messages['error']) || ($form && count((array)form_get_errors()) > 0);
  return array(
    'success'  => $success,
    'messages'   => $messages,
  );
}

/**
 * Internal function to save a message.
 *
 * @param $message
 *   A $message array with the data that should be saved. If a thread_id exists
 *   it will be created as a reply to an existing thread. If not, a new thread
 *   will be created.
 *
 * @return
 *   The updated $message array.
 */
function _privatemsg_send($message) {

  drupal_alter('privatemsg_message_presave', $message);

  $index_sql = "INSERT INTO {pm_index} (mid, thread_id, uid, is_new, deleted) VALUES (%d, %d, %d, %d, 0)";
  if (isset($message['read_all']) && $message['read_all']) {
    // The message was sent in read all mode, add the author as recipient to all
    // existing messages.
    $query_messages = _privatemsg_assemble_query('messages', array($message['thread_id']), NULL);
    $conversation = db_query($query_messages['query']);
    while ($result = db_fetch_array($conversation)) {
      if (!db_query($index_sql, $result['mid'], $message['thread_id'], $message['author']->uid, 0)) {
        return FALSE;
      }
    }
  }

  // 1) Save the message body first.
  $args = array();
  $args[] = $message['subject'];
  $args[] = $message['author']->uid;
  $args[] = $message['body'];
  $args[] = $message['format'];
  $args[] = $message['timestamp'];
  $message_sql = "INSERT INTO {pm_message} (subject, author, body, format, timestamp) VALUES ('%s', %d, '%s', %d, %d)";
  db_query($message_sql, $args);
  $mid = db_last_insert_id('pm_message', 'mid');
  $message['mid'] = $mid;

  // Thread ID is the same as the mid if it's the first message in the thread.
  if (!isset($message['thread_id'])) {
    $message['thread_id'] = $mid;
  }

  // 2) Save message to recipients.
  // Each recipient gets a record in the pm_index table.
  foreach ($message['recipients'] as $recipient) {
    if (!db_query($index_sql, $mid, $message['thread_id'], $recipient->uid, 1) ) {
      // We assume if one insert failed then the rest may fail too against the
      // same table.
      return FALSE;
    }
  }

  // When author is also the recipient, we want to set message to UNREAD.
  // All other times the message is set to READ.
  $is_new = isset($message['recipients'][$message['author']->uid]) ? 1 : 0;

  // Also add a record for the author to the pm_index table.
  if (!db_query($index_sql, $mid, $message['thread_id'], $message['author']->uid, $is_new)) {
    return FALSE;
  }

  module_invoke_all('privatemsg_message_insert', $message);

  // If we reached here that means we were successful at writing all messages to db.
  return $message;
}

/**
 * Returns a link to send message form for a specific users.
 *
 * Contains permission checks of author/recipient, blocking and
 * if a anonymous user is involved.
 *
 * @param $recipient
 *   Recipient of the message
 * @param $account
 *   Sender of the message, defaults to the current user
 *
 * @return
 *   Either FALSE or a URL string
 *
 * @ingroup api
 */
function privatemsg_get_link($recipients, $account = array(), $subject = NULL) {
  if ($account == NULL) {
    global $user;
    $account = $user;
  }

  if (!is_array($recipients)) {
    $recipients = array($recipients);
  }

  if (!privatemsg_user_access('write privatemsg', $account) || $account->uid == 0) {
    return FALSE;
  }

  $validated = array();
  foreach ($recipients as $recipient) {
    if (!privatemsg_user_access('read privatemsg', $recipient)) {
      continue;
    }
    if (variable_get('privatemsg_display_link_self', TRUE) == FALSE && $account->uid == $recipient->uid) {
      continue;
    }
    if (count(module_invoke_all('privatemsg_block_message', $account, array($recipient))) > 0) {
      continue;
    }
    $validated[] = $recipient->uid;
  }
  if (empty($validated)) {
    return FALSE;
  }
  $url = 'messages/new/'. implode(',', $validated);
  if (!is_null($subject)) {
    $url .= '/'. $subject;
  }
  return $url;
}

/**
 * Load a single message.
 *
 * @param $pmid
 *   Message id, pm.mid field
 * @param $account
 *   For which account the message should be loaded.
 *   Defaults to the current user.
 *
 * @ingroup api
 */
function privatemsg_message_load($pmid, $account = NULL) {
  $messages = privatemsg_message_load_multiple(array($pmid), $account);
  return current($messages);
}

/**
 * Load multiple messages.
 *
 * @param $pmids
 *   Array of Message ids, pm.mid field
 * @param $account
 *   For which account the message should be loaded.
 *   Defaults to the current user.
 *
 * @ingroup api
 */
function privatemsg_message_load_multiple($pmids, $account = NULL) {
  // Avoid SQL error that would happen with an empty pm.mid IN () clause.
  if (empty($pmids)) {
    return array();
  }

  $query = _privatemsg_assemble_query('load', $pmids, $account);
  $result = db_query($query['query']);
  $messages = array();
  while ($message = db_fetch_array($result)) {
    // Load author of message.
    if (!($message['author'] = user_load($message['author']))) {
      // If user does not exist, load anonymous user.
      $message['author'] = user_load(array('uid' => 0));
    }
    $returned = module_invoke_all('privatemsg_message_load', $message);
    if (!empty($returned)) {
      $message = array_merge_recursive($returned, $message);
    }
    $messages[$message['mid']] = $message;
  }
  return $messages;
}

/**
 * Generates a query based on a query id.
 *
 * @param $query
 *   Either be a string ('some_id') or an array('group_name', 'query_id'),
 *   if a string is supplied, group_name defaults to 'privatemsg'.
 *
 * @return
 *    Array with the keys query and count. count can be used to count the
 *    elements which would be returned by query. count can be used together
 *    with pager_query().
 *
 * @ingroup sql
 */
function _privatemsg_assemble_query($query) {

  // Modules will be allowed to choose the prefix for the querybuilder, but if there is not one supplied, 'privatemsg' will be taken by default.
  if (is_array($query)) {
    $query_id = $query[0];
    $query_group = $query[1];
  }
  else {
    $query_id = $query;
    $query_group = 'privatemsg';
  }

  $SELECT = array();
  $INNER_JOIN = array();
  $WHERE = array();
  $GROUP_BY = array();
  $HAVING   = array();
  $ORDER_BY = array();
  $QUERY_ARGS = array('select' => array(), 'where' => array(), 'join' => array(), 'having' => array());
  $primary_table = '';

  $fragments = array(
    'select'      => $SELECT,
    'inner_join'  => $INNER_JOIN,
    'where'       => $WHERE,
    'group_by'    => $GROUP_BY,
    'having'      => $HAVING,
    'order_by'    => $ORDER_BY,
    'query_args'  => $QUERY_ARGS,
    'primary_table'  => $primary_table,
  );

  /**
   * Begin: dynamic arguments
   */
  $args = func_get_args();
  unset($args[0]);
  // we do the merge because we call call_user_func_array and not drupal_alter
  // this is necessary because otherwise we would not be able to use $args correctly (otherwise it doesnt unfold)
  $alterargs = array(&$fragments);
  $query_function = $query_group .'_sql_'. $query_id;
  if (!empty($args)) {
    $alterargs = array_merge($alterargs, $args);
  }
  /**
   * END: Dynamic arguments
   */
  if (!function_exists($query_function)) {
    drupal_set_message(t('Query function %function does not exist', array('%function' => $query_function)), 'error');
    return FALSE;
  }
  call_user_func_array($query_function, $alterargs);

  array_unshift($alterargs, $query_function);
  call_user_func_array('drupal_alter', $alterargs);

  $SELECT = $fragments['select'];
  $INNER_JOIN = $fragments['inner_join'];
  $WHERE = $fragments['where'];
  $GROUP_BY = $fragments['group_by'];
  $HAVING   = $fragments['having'];
  $ORDER_BY = $fragments['order_by'];
  $QUERY_ARGS = $fragments['query_args'];
  $primary_table = $fragments['primary_table'];

  // pgsql has a case sensitive LIKE - replace it with ILIKE. see http://drupal.org/node/462982
  if ($GLOBALS['db_type'] == 'pgsql') {
    $WHERE = str_replace('LIKE', 'ILIKE', $WHERE);
  }

  if (empty($primary_table)) {
    $primary_table = '{privatemsg} pm';
  }

  // Perform the whole query assembly only if we have something to select.
  if (!empty($SELECT)) {
    $str_select = implode(", ", $SELECT);
    $query = "SELECT {$str_select} FROM ". $primary_table;

    // Also build a count query which can be passed to pager_query to get a "page count" as that does not play well with queries including "GROUP BY".
    // In most cases,  "COUNT(*)" is enough to get the count query, but in queries involving a GROUP BY, we want a count of the number of groups we have, not the count of elements inside each group.
    // So we test if there is GROUP BY and if there is, count the number of distinct groups. If not, we go the normal wal and do a plain COUNT(*).
    if (!empty($GROUP_BY)) {
      // PostgreSQL does not support COUNT(sometextfield, someintfield), so I'm only using the first one
      // Works fine for thread_id/list but may generate an error when a more complex GROUP BY is used.
      $str_group_by_count = current($GROUP_BY);
      $count = "SELECT COUNT(DISTINCT {$str_group_by_count}) FROM ". $primary_table;
    }
    else {
      $count = "SELECT COUNT(*) FROM ". $primary_table;
    }

    if (!empty($INNER_JOIN)) {
      $str_inner_join = implode(' ', $INNER_JOIN);
      $query .= " {$str_inner_join}";
      $count .= " {$str_inner_join}";
    }
    if (!empty($WHERE)) {
      $str_where = '('. implode(') AND (', $WHERE) .')';
      $query .= " WHERE {$str_where}";
      $count .= " WHERE {$str_where}";
    }
    if (!empty($GROUP_BY)) {
      $str_group_by = ' GROUP BY '. implode(", ", $GROUP_BY) ;
      $query .= " {$str_group_by}";
    }
    if (!empty($HAVING)) {
      $str_having = '('. implode(') AND (', $HAVING) .')';
      $query .= " HAVING {$str_having}";
      // queries containing a HAVING break the count query on pgsql.
      // In this case, use the subquery method as outlined in http://drupal.org/node/303087#comment-1370752 .
      // The subquery method will work for all COUNT queries, but it is thought to be much slower, so we are only using it where other cross database approaches fail.
      $count = 'SELECT COUNT(*) FROM ('. $query .') as count';
    }
    if (!empty($ORDER_BY)) {
      $str_order_by = ' ORDER BY '. implode(", ", $ORDER_BY) ;
      $query .= " {$str_order_by}";
    }
    $QUERY_ARGS = array_merge($QUERY_ARGS['select'], $QUERY_ARGS['join'], $QUERY_ARGS['where'], $QUERY_ARGS['having']);
    if (!empty($QUERY_ARGS)) {
      _db_query_callback($QUERY_ARGS, TRUE);
      $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
      _db_query_callback($QUERY_ARGS, TRUE);
      $count = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $count);
    }
    return array('query' => $query, 'count' => $count);
  }
  return FALSE;
}

/**
 * Marks one or multiple threads as (un)read.
 *
 * @param $threads
 *   Array with thread id's or a single thread id.
 * @param $status
 *   Either PRIVATEMSG_READ or PRIVATEMSG_UNREAD, sets the new status.
 * @param $account
 *   User object for which the threads should be deleted, defaults to the
 *   current user.
 */
function privatemsg_thread_change_status($threads, $status, $account = NULL) {
  if (!is_array($threads)) {
    $threads = array($threads);
  }
  if (empty($account)) {
    global $user;
    $account = drupal_clone($user);
  }
  // Merge status and uid with the threads list. array_merge() will not overwrite/ignore thread_id 1.
  $params = array_merge(array($status, $account->uid), $threads);
  db_query('UPDATE {pm_index} SET is_new = %d WHERE uid = %d AND thread_id IN ('. db_placeholders($threads) .')', $params);

  if ($status == PRIVATEMSG_UNREAD) {
    drupal_set_message(format_plural(count($threads), 'Marked 1 thread as unread.', 'Marked @count threads as unread.'));
  }
  else {
    drupal_set_message(format_plural(count($threads), 'Marked 1 thread as read.', 'Marked @count threads as read.'));
  }
}

/**
 * Execute an operation on a number of threads.
 *
 * @param $operation
 *   The operation that should be executed.
 *   @see hook_privatemsg_thread_operations()
 * @param $threads
 *   An array of thread ids. The array is filtered before used, a checkboxes
 *   array can be directly passed to it.
 */
function privatemsg_operation_execute($operation, $threads, $account = null) {
  // Filter out unchecked threads, this gives us an array of "checked" threads.
  $threads = array_filter($threads);

  if (empty($threads)) {
    // Do not execute anything if there are no checked threads.
    return;
  }
  // Add in callback arguments if present.
  if (isset($operation['callback arguments'])) {
    $args = array_merge(array($threads), $operation['callback arguments']);
  }
  else {
    $args = array($threads);
  }

  // Add the user object to the arguments.
  if ($account) {
    $args[] = $account;
  }

  // Execute the chosen action and pass the defined arguments.
  call_user_func_array($operation['callback'], $args);

  // Check if that operation has defined an undo callback.
  if (isset($operation['undo callback']) && $undo_function = $operation['undo callback']) {
    // Add in callback arguments if present.
    if (isset($operation['undo callback arguments'])) {
      $undo_args = array_merge(array($threads), $operation['undo callback arguments']);
    }
    else {
      $undo_args = array($threads);
    }

    // Avoid saving the complete user object in the session.
    if ($account) {
      $undo_args['account'] = $account->uid;
    }
    // Store the undo callback in the session and display a "Undo" link.
    // @todo: Provide a more flexible solution for such an undo action, operation defined string for example.
    $_SESSION['privatemsg']['undo callback'] = array('function' => $undo_function, 'args' => $undo_args);
    $undo = url('messages/undo/action', array('query' => drupal_get_destination()));

    drupal_set_message(t('The previous action can be <a href="!undo">undone</a>.', array('!undo' => $undo)));
  }
}

/**
 * Delete or restore one or multiple threads.
 *
 * @param $threads
 *   Array with thread id's or a single thread id.
 * @param $delete
 *   Indicates if the threads should be deleted or restored.
 *   1 => delete, 0 => restore.
 * @param $account
 *   User object for which the threads should be deleted,
 *   defaults to the current user.
 */
function privatemsg_thread_change_delete($threads, $delete, $account = NULL) {
  if (!is_array($threads)) {
    $threads = array($threads);
  }
  if (empty($account)) {
    global $user;
    $account = drupal_clone($user);
  }

  // Merge status and uid with the threads list. array_merge() will not overwrite/ignore thread_id 1.
  $params = array_merge(array($delete, $account->uid), $threads);

  // Load all messages of those threads including the deleted.
  $query = _privatemsg_assemble_query('messages', $threads, $account, TRUE);
  $result = db_query($query['query']);

  // Delete each message. We need to do that to trigger the delete hook.
  while ($row = db_fetch_array($result)) {
    privatemsg_message_change_delete($row['mid'], $delete, $account);
  }

  if ($delete) {
    drupal_set_message(format_plural(count($threads), 'Deleted 1 thread.', 'Deleted @count threads.'));
  }
  else {
    drupal_set_message(format_plural(count($threads), 'Restored 1 thread.', 'Restored @count threads.'));
  }
}

/**
 * Implementation of hook_privatemsg_block_message.
 */
function privatemsg_privatemsg_block_message($author, $recipients) {
  $blocked = array();
  if (privatemsg_is_disabled($author)) {
    $blocked[] = array('uid' => $author->uid,
                       'message' => t('You have disabled private message sending and receiving.'),
                 );
  }
  foreach($recipients as $recipient) {
    if (privatemsg_is_disabled($recipient)) {
      $blocked[] = array('uid' => $recipient->uid,
                       'message' => t('%recipient has disabled private message receiving.', array('%recipient' => $recipient->name))
                 );
    }
  }

  return $blocked;
}

/**
 * Implements hook_privatemsg_thread_operations().
 */
function privatemsg_privatemsg_thread_operations() {
  $operations = array(
    'mark as read' => array(
      'label' => t('Mark as read'),
      'callback' => 'privatemsg_thread_change_status',
      'callback arguments' => array('status' => PRIVATEMSG_READ),
      'undo callback' => 'privatemsg_thread_change_status',
      'undo callback arguments' => array('status' => PRIVATEMSG_UNREAD),
    ),
    'mark as unread' => array(
      'label' => t('Mark as unread'),
      'callback' => 'privatemsg_thread_change_status',
      'callback arguments' => array('status' => PRIVATEMSG_UNREAD),
      'undo callback' => 'privatemsg_thread_change_status',
      'undo callback arguments' => array('status' => PRIVATEMSG_READ),
    ),
  );
  if (privatemsg_user_access('delete privatemsg')) {
    $operations['delete'] = array(
      'callback' => 'privatemsg_thread_change_delete',
      'callback arguments' => array('delete' => 1),
      'undo callback' => 'privatemsg_thread_change_delete',
      'undo callback arguments' => array('delete' => 0),
    );
  }
  return $operations;
}

/**
 * Integration of hook_popups() of the popups module.
 */
function privatemsg_popups() {
  if (variable_get('privatemsg_popups', TRUE)) {
    return array(
      '*' => array(
        'a[href*=messages/new]' // Write new message
       ),
    );
  }
}

/**
 * Implements hook_link().
 */
function privatemsg_link($type, $object, $teaser = FALSE) {
  global $user;
  static $nodes = array();

  $links = array();
  if (!isset($nodes[$object->uid])) {
    if ($type == 'node') {
      $nodes[$object->nid] = $object;
    }
    elseif ($type == 'comment') {
      $nodes[$object->nid] = node_load($object->nid);
    }
  }

  $types = array_filter(variable_get('privatemsg_link_node_types', array()));
  $url = privatemsg_get_link(user_load($object->uid));
  if ($type == 'node' && in_array($object->type, $types) && !empty($url) && ($teaser == FALSE || variable_get('privatemsg_display_on_teaser', 1))) {
    $links['privatemsg_link'] = array(
      'title' => t('Send author a message'),
      'href' => $url . '/' . t('Message regarding @node', array( '@node' => $object->title)),
      'query' => drupal_get_destination(),
    );
  }
  if ($type == 'comment' && in_array($nodes[$object->nid]->type, $types) && !empty($url) && variable_get('privatemsg_display_on_comments', 0)) {
    $links['privatemsg_link'] = array(
      'title' => t('Send private message'),
      'href' => $url . '/' . t('Message regarding @comment', array( '@comment' => $object->subject)),
      'query' => drupal_get_destination(),
    );
  }
  return $links;
}

/**
 * Implementation of hook_views_api().
 */
function privatemsg_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'privatemsg') . '/views',
  );
}