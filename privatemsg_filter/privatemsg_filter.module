<?php
// $Id$

/**
 * @file
 * Allows users to tag private messages and to filter based upon those tags.
 */

/**
 * Implementats hook_permission().
 */
function privatemsg_filter_permission() {
  return array(
    'filter private messages' => array(
      'title' => t('Filter private messages'),
      'description' => t('Use the search and filter widget'),
    ),
    'tag private messages' => array(
      'title' => t('Tag private messages'),
      'description' => t('Tag private messages'),
    ),
    'create private message tags' => array(
      'title' => t('Create private message tags'),
      'description' => t('Create new private message tags'),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function privatemsg_filter_menu() {
  $items['admin/config/people/messages/filter'] = array(
    'title'            => 'Filter',
    'description'      => 'Configure filter settings.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_filter_admin'),
    'access arguments' => array('administer privatemsg settings'),
    'type'             => MENU_LOCAL_TASK,
  );
  $items['messages/list/all'] = array(
    'title'            => 'All messages',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'list'),
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_DEFAULT_LOCAL_TASK,
    'weight'           => -10,
    'menu_name'        => 'user-menu',
  );
  $items['messages/list/inbox'] = array(
    'title'            => 'Inbox',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'inbox'),
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_LOCAL_TASK,
    'weight'           => -10,
    'menu_name'        => 'user-menu',
  );
  $items['messages/list/sent'] = array(
    'title'            => 'Sent Messages',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('privatemsg_list', 'sent'),
    'access callback'  => 'privatemsg_user_access',
    'type'             => MENU_LOCAL_TASK,
    'weight'           => -10,
    'menu_name'        => 'user-menu',
  );
  $items['messages/filter/user-name-autocomplete'] = array(
    'page callback'    => 'privatemsg_user_name_autocomplete',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('write privatemsg'),
    'type'             => MENU_CALLBACK,
    'weight'           => -10,
  );
  $items['messages/filter/tag-autocomplete'] = array(
    'page callback'    => 'privatemsg_filter_tags_autocomplete',
    'access callback'  => 'privatemsg_user_access',
    'access arguments' => array('tag private messages'),
    'type'             => MENU_CALLBACK,
    'weight'           => -10,
  );
  return $items;
}

function privatemsg_filter_admin() {
  $form = array();

  $form['privatemsg_filter_searchbody'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Search message body'),
    '#description'   => t('WARNING: turning on this feature will slow down search performance by a large factor. Gets worse as your messages database increases.'),
    '#default_value' => variable_get('privatemsg_filter_searchbody', FALSE),
  );

  $form['privatemsg_filter_tagfield_weight'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Position of the tagging textfield'),
    '#description'   => t('Use higher values to push the form lower down the page, lower or negative values to raise it higher.'),
    '#size'          => 4,
    '#default_value' => variable_get('privatemsg_filter_tagfield_weight', 10),
  );

  return system_settings_form($form);
}

function privatemsg_filter_get_filter($account) {
  $filter = array();
  if (isset($_GET['tags'])) {
    $_GET['tags'] = urldecode($_GET['tags']);
    $tag_data = privatemsg_filter_get_tags_data($account);
    foreach (explode(',', $_GET['tags']) as $tag) {
      if (isset($tag_data[$tag])) {
        $filter['tags'][$tag] = $tag;
      }
      elseif (in_array($tag, $tag_data)) {
        $filter['tags'][array_search($tag, $tag_data)] = array_search($tag, $tag_data);
      }
    }
  }

  if (isset($_GET['author'])) {
    list($filter['author']) = _privatemsg_parse_userstring($_GET['author']);
  }

  if (isset($_GET['search'])) {
    $filter['search'] = $_GET['search'];
  }

  if(!empty($filter)) {
    return $filter;
  }

  if (!empty($_SESSION['privatemsg_filter'])) {
    return $_SESSION['privatemsg_filter'];
  }

}

function privatemsg_filter_get_tags_data($account) {
 static $tag_data;

  if (is_array($tag_data)) {
    return $tag_data;
  }

  // Only show the tags that a user have used.
  return $tag_data = _privatemsg_assemble_query(array('used_tags', 'privatemsg_filter'), $account)->execute()->fetchAllKeyed();
}

function privatemsg_filter_dropdown(&$form_state, $account) {

  drupal_add_css(drupal_get_path('module', 'privatemsg_filter') . '/privatemsg_filter.css');

  $form['filter'] = array(
    '#type' => 'fieldset',
    '#title' => t('Filter Messages'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['filter']['search'] = array(
    '#type' => 'textfield',
    '#title' => variable_get('privatemsg_filter_searchbody', FALSE) ? t('Search messages') : t('Search subjects'),
    '#weight' => -20
  );

  $form['filter']['author'] = array(
    '#type'               => 'textfield',
    '#title'              => t('Participants'),
    '#description'        => t('Separate multiple names with commas.'),
    '#weight'             => -5,
    '#size'               => 50,
    '#autocomplete_path'  => 'messages/filter/user-name-autocomplete',
  );

  // Only show form if the user has some messages tagged.
  if (count($tag_data = privatemsg_filter_get_tags_data($account))) {
    $form['filter']['tags'] = array(
      '#type' => 'select',
      '#title' => t('Tags'),
      '#options' => $tag_data,
      '#multiple' => TRUE,
      '#size' => 5,
      '#weight' => 0
    );
  }
  $form['filter']['submit'] = array(
    '#type'     => 'submit',
    '#value'    => t('Filter'),
    '#prefix'   => '<div id="privatemsg-filter-buttons">',
    '#weight'   => 10,
    '#submit'   => array('privatemsg_filter_dropdown_submit'),
  );

  $form['filter']['save'] = array(
    '#type'     => 'submit',
    '#value'    => t('Save Filter'),
    '#suffix'   => '</div>',
    '#weight'   => 11,
    '#submit'   => array('privatemsg_filter_dropdown_submit'),
  );

  if ($filter = privatemsg_filter_get_filter($account)) {
    privatemsg_filter_dropdown_set_active($form, $filter);
  }

  return $form;
}

function privatemsg_filter_dropdown_set_active(&$form, $filter) {
  $form['filter']['#title'] = t('Filter Messages (Active)');
  $form['filter']['#collapsed'] = FALSE;

  if (isset($filter['author'])) {
    $string = '';
    foreach ($filter['author'] as $author) {
      $string .= $author->name . ', ';
    }
    $form['filter']['author']['#default_value'] = $string;
  }
  if (isset($filter['tags'])) {
    $form['filter']['tags']['#default_value'] = $filter['tags'];
  }
  if (isset($filter['search'])) {
    $form['filter']['search']['#default_value'] = $filter['search'];
  }

  $form['filter']['reset'] = array(
      '#type'     => 'submit',
      '#value'    => t('Reset'),
      '#suffix'   => '</div>',
      '#weight'   => 12,
      '#submit'   => array('privatemsg_filter_dropdown_submit'),
  );
  unset($form['filter']['save']['#suffix']);
}

function privatemsg_filter_dropdown_submit($form, &$form_state) {

  if (!empty($form_state['values']['author'])) {
    list($form_state['values']['author']) = _privatemsg_parse_userstring($form_state['values']['author']);
  }

  switch ($form_state['values']['op']) {
    case t('Save Filter'):
      $filter = array();
      if (!empty($form_state['values']['tags'])) {
        $filter['tags'] = $form_state['values']['tags'];
      }
      if (!empty($form_state['values']['author'])) {
        $filter['author'] = $form_state['values']['author'];
      }
      if (!empty($form_state['values']['search'])) {
        $filter['search'] = $form_state['values']['search'];
      }
      $_SESSION['privatemsg_filter'] = $filter;
      break;
    case t('Filter'):
      drupal_goto($_GET['q'], privatemsg_filter_create_get_query($form_state['values']));
      return;
      break;
    case t('Reset'):
      $_SESSION['privatemsg_filter'] = array();
      break;
  }
  $form_state['redirect'] = $_GET['q'];
}

function privatemsg_filter_create_get_query($filter)
{
  $query = array();
  if (isset($filter['tags']) && !empty($filter['tags'])) {
    $ids = array();
    foreach ($filter['tags'] as $tag) {
      if ((int)$tag > 0) {
        $ids[] = $tag;
      }
      else {
        $query['tags'][] = $tag;
      }
    }
    $sql = 'SELECT pmt.tag FROM {pm_tags} pmt WHERE pmt.tag_id IN (:tags)';
    $query['tags'] = db_query($sql, array(':tags' => $filter['tags']))->fetchAll();

    if (isset($query['tags'])) {
      $query['tags'] = implode(',', $query['tags']);
    }
  }

  if (isset($filter['author']) && !empty($filter['author'])) {
    foreach ($filter['author'] as $author) {
      if (is_object($author) && isset($author->uid) && isset($author->name)) {
        $query['author'][] = $author->name;
      }
      elseif ($author_obj = user_load($author)) {
        $query['author'][] = $author_obj->name;
      }
    }
    if (isset($query['author'])) {
      $query['author'] = implode(',', $query['author']);
    }
  }

  if (isset($filter['search']) && !empty($filter['search'])) {
    $query['search'] = $filter['search'];
  }
  return $query;
}

/**
 * Implementation of hook_form_alter() to add a filter widget to the message listing pages.
 */
function privatemsg_filter_form_privatemsg_list_alter(&$form, $form_state) {
  if (privatemsg_user_access('filter private messages')) {
    $form += privatemsg_filter_dropdown($form_state, $form['#account']);
  }
}


/**
 * Hook into the query builder to add the tagging info to the correct query
 */
function privatemsg_filter_query_privatemsg_list_alter($query) {

  $account = $query->getMetaData('arg_1');
  $argument = $query->getMetaData('arg_2');

  // Check if its a filtered view.
  if ($argument == 'sent') {
    $query->condition('pm.author', $account->uid);
  }
  if ($argument == 'inbox') {
    $query->having('((SELECT pmf.author FROM {pm_message} pmf WHERE pmf.mid = pmi.thread_id) = :uid1 AND COUNT(pmi.thread_id) > 1) OR (SELECT pmf.author FROM {pm_message} pmf WHERE pmf.mid = pmi.thread_id) <> :uid2', array(
      ':uid1' => $account->uid,
      ':uid2' => $account->uid,
    ));
  }

  // Filter the message listing by any set tags.
  if ($filter = privatemsg_filter_get_filter($account)) {
    $count = 0;
    if (isset($filter['tags']) && !empty($filter['tags'])) {
      foreach ($filter['tags'] as $tag) {
        $query->join('pm_tags_index', "pmti$count", "pmti$count.thread_id = pmi.thread_id AND pmti$count.uid = pmi.uid");
        $query->condition("pmti$count.tag_id", $tag);
        $count++;
      }
    }

    if (isset($filter['author']) && !empty($filter['author'])) {
      foreach ($filter['author'] as $author) {
        $query->join('pm_index', 'pmi' . $count, "pmi$count.mid = pm.mid");
        $query->condition("pmi$count.uid", $author->uid);
        $count++;
      }
    }

    if (isset($filter['search']) && !empty($filter['search'])) {
      if (variable_get('privatemsg_filter_searchbody', FALSE)) {
        $query->condition(db_or()
          ->condition('pm.subject', '%'. $filter['search'] .'%', 'LIKE')
          ->condition('pm.body', '%'. $filter['search'] .'%', 'LIKE')
        );
      }
      else {
        $query->condition('pm.subject', '%'. $filter['search'] .'%', 'LIKE');
      }
    }
  }
}

/**
 * Hook into the view messages page to add a form for tagging purposes.
 */
function privatemsg_filter_page_alter(&$page) {
  if (isset($page['content']['system_main']['messages']) && count($page['content']['system_main']['messages']) && privatemsg_user_access('tag private messages')) {
    $page['content']['system_main']['tags'] = drupal_get_form('privatemsg_filter_form');
    $page['content']['system_main']['tags']['#weight'] = variable_get('privatemsg_filter_tagfield_weight', 10);
  }
}

/**
 * Form to show and allow modification of tagging information for a conversation.
 */
function privatemsg_filter_form(&$form_state) {
  global $user;
  $thread_id = arg(2);

  // Get a list of current tags for this thread
  $query = _privatemsg_assemble_query(array('used_tags', 'privatemsg_filter'), $user, $thread_id);
  $count = $query->countQuery()->execute()->fetchField();
  $tags = implode(', ', $query->execute()->fetchCol(1));

  $form['tags'] = array(
    '#type' => 'fieldset',
    '#title' => t('Tags'),
    '#access' => privatemsg_user_access('tag private messages'),
    '#collapsible' => TRUE,
    '#collapsed' => empty($count) ? TRUE : FALSE,
  );
  $form['tags']['user_id'] = array(
    '#type' => 'value',
    '#value' => $user->uid,
  );
  $form['tags']['thread_id'] = array(
    '#type' => 'value',
    '#value' => $thread_id,
  );

  $form['tags']['tags'] = array(
    '#type'               => 'textfield',
    '#title'              => t('Tags for this conversation'),
    '#description'        => t('Separate multiple tags with commas.'),
    '#size'               => 50,
    '#default_value'      => $tags,
    '#autocomplete_path'  => 'messages/filter/tag-autocomplete',
  );

  $form['tags']['submit'] = array(
    '#type'     => 'submit',
    '#value'    => t('Tag this conversation'),
    '#submit'   => array('privatemsg_filter_form_submit'),
  );

  return $form;
}

function privatemsg_filter_form_submit($form, &$form_state) {
  if (isset($form_state['values']['submit'])) {
    $tags = explode(',', $form_state['values']['tags']);

    // Step 1 - Delete all tag mapping. I cannot think of a better way to remove tags that are no longer in the textfield, so ideas welcome.
    db_delete('pm_tags_index')
      ->condition('uid', $form_state['values']['user_id'])
      ->condition('thread_id', $form_state['values']['thread_id'])
      ->execute();

    foreach ($tags as $tag) {
      // Step 2 - We need to sanitise the tag.
      // Since we allow tags to be passed via the url, there needs to be some sanity testing of each tag.
      // Currently we replace blank spaces and a # with a "-", but this needs to be expanded to cover all the url special cases.
      $tag = trim($tag);
      if (empty($tag)) {
        // Do not save a blank tag.
        continue;
      }

      // Step 3 - Make sure that the tag exists and if it does not, we need to create it.
      $tag_id = db_query("SELECT tag_id FROM {pm_tags} WHERE tag = :tag", array(':tag' => $tag))->fetchField();
      if (empty($tag_id) && privatemsg_user_access('create private message tags')) {
        $tag_id = db_insert('pm_tags')
          ->fields(array('tag' => $tag))
          ->execute();
      }
      elseif (empty($tag_id)) {
        // The user does not have permission to create new tags - disregard this tag and move onto the next.
        drupal_set_message(t('Tag %tag was ignored because you do not have permission to create new tags.', array('%tag' => $tag)));
        continue;
      }

      // Step 4 - map the tag to the thread and the user.
      db_insert('pm_tags_index')
        ->fields(array(
          'tag_id' => $tag_id,
          'uid'    => $form_state['values']['user_id'],
          'thread_id' => $form_state['values']['thread_id'],
        ))
        ->execute();
      }
  drupal_set_message(t('Tagging information has been saved.'));
  }
}

/**
 * Return autocomplete results for tags.
 *
 * Most of this code has been lifted/modified from privatemsg_user_name_autocomplete().
 */
function privatemsg_filter_tags_autocomplete($string) {

  // 1: Parse $string and build a list of tags.
  $tags = array();
  $fragments = explode(',', $string);
  foreach ($fragments as $index => $tag) {
    $tag = trim($tag);
    $tags[$tag] = $tag;
  }

  // 2: Find the next tag suggestion.
  $fragment = array_pop($tags);
  $matches = array();
  if (!empty($fragment)) {
    $query = _privatemsg_assemble_query(array('tags_autocomplete', 'privatemsg_filter'), $fragment, $tags);
    $prefix = count($tags) ? implode(", ", $tags) .", " : '';
    // 3: Build proper suggestions and print.
    foreach ($query->execute() as $tag) {
      $matches[$prefix . $tag->tag .", "] = $tag->tag;
    }
  }
  // convert to object to prevent drupal bug, see http://drupal.org/node/175361
  drupal_json((object)$matches);
}

/**
 * Limit the user autocomplete for the filter widget.
 */
function privatemsg_filter_query_privatemsg_autocomplete_alter($query) {
  global $user;
  if (arg(1) == 'filter') {
    $query->join('pm_index', 'pip', 'pip.uid = u.uid');
    $query->join('pm_index', 'piu', 'piu.uid = :uid_index AND pip.mid = piu.mid', array(':uid_index' => $user->uid));
  }
}

/**
 * Query definition to get the tags in use by the specified user.
 *
 * @param $user
 *  User object for whom we want the tags.
 * @param $thread_id
 *  The thread_id - Only needed if we want the tags for a specific thread instead of all used tags on any thread.
 */
function privatemsg_filter_sql_used_tags($user, $thread_id = NULL) {
  $query = db_select('pm_tags', 't')
    ->fields('t', array('tag_id', 'tag'))
    ->condition('ti.uid', $user->uid)
    ->orderBy('t.tag', 'ASC');
  $query->join('pm_tags_index', 'ti', 'ti.tag_id = t.tag_id');
  if (!empty($thread_id)) {
    $query->condition('ti.thread_id', $thread_id);
  }
  return $query;
}

/**
 * Query definition to get autocomplete suggestions for tags
 *
 * @param $search
 *  String fragment to use for tag suggestions.
 * @param $tags
 *  Array of tags not to be used as suggestions.
 */
function privatemsg_filter_sql_tags_autocomplete($search, $tags) {
  $query = db_select('pm_tags', 'pmt')
    ->fields('pmt', array('tag'))
    ->condition('pmt.tag', $search . '%%', 'LIKE')
    ->orderBy('pmt.tag', 'ASC')
    ->range(0, 10);

  if (!empty($tags)) {
    $query->condition('pmt.tag', $tags, 'NOT IN');
  }
  return $query;
}