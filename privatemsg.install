<?php
// $Id$

function privatemsg_install() {
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      db_query("CREATE TABLE {privatemsg} (
          id            int unsigned NOT NULL primary key,
          author        int unsigned NOT NULL,
          recipient     int unsigned NOT NULL,
          subject       varchar(255) NOT NULL,
          message       text NOT NULL,
          timestamp     int unsigned NOT NULL,
          newmsg        tinyint unsigned NOT NULL,
          hostname      varchar(255) NOT NULL,
          folder        int unsigned NOT NULL DEFAULT 0,
          author_del    tinyint unsigned NOT NULL DEFAULT 0,
          recipient_del tinyint unsigned NOT NULL DEFAULT 0,
          format        int NOT NULL DEFAULT 0,
          thread        int NOT NULL DEFAULT 0,
          type          varchar(255) NOT NULL,
          key (recipient),
          key (folder),
          key(type),
          key(author)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
      db_query("CREATE TABLE {privatemsg_folder} (
          fid           int unsigned NOT NULL primary key,
          uid           int unsigned NOT NULL,
          name          varchar(255) NOT NULL
        ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
      db_query("CREATE TABLE {privatemsg_archive} (
          id            int unsigned NOT NULL primary key,
          author        int unsigned NOT NULL,
          recipient     int unsigned NOT NULL,
          subject       VARCHAR(64) NOT NULL,
          message       text NOT NULL,
          timestamp     int unsigned NOT NULL,
          hostname      varchar(255) NOT NULL,
          folder        int unsigned NOT NULL,
          format        int NOT NULL DEFAULT 0,
          thread        int NOT NULL DEFAULT 0,
          key (recipient)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
      db_query("CREATE TABLE {privatemsg_mail_edit} (
          type varchar(255) NOT NULL,
          mailkey varchar(255) NOT NULL,
          PRIMARY KEY  (mailkey)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
      db_query('CREATE TABLE {privatemsg_block_user} (
          author int unsigned NOT NULL,
          recipient int unsigned NOT NULL,
          PRIMARY KEY (author, recipient)
        )  /*!40100 DEFAULT CHARACTER SET utf8 */');
      break;
      /*
                notification_subject varchar(255) NOT NULL,
          notification_text_body varchar(255) NOT NULL,
          notification_html_body varchar(255) NOT NULL,
          notification_group_text_body varchar(255) NOT NULL,
          notification_group_html_body varchar(255) NOT NULL,
*/
    case 'pgsql':
      db_query("CREATE TABLE {privatemsg} (
          id            integer NOT NULL,
          author        integer NOT NULL,
          recipient     integer NOT NULL,
          subject       varchar(255) NOT NULL,
          message       text NOT NULL,
          timestamp     integer NOT NULL,
          newmsg        smallint NOT NULL,
          hostname      varchar(255) NOT NULL,
          format        smallint NOT NULL DEFAULT 0,
          folder        integer NOT NULL DEFAULT 0,
          author_del    smallint NOT NULL DEFAULT 0,
          recipient_del smallint NOT NULL DEFAULT 0,
          thread        int NOT NULL DEFAULT 0,
          type          varchar(255) NOT NULL,
          PRIMARY KEY (id)
        )");
      db_query("CREATE INDEX {privatemsg_folder_index} ON {privatemsg}(folder)");
      db_query("CREATE INDEX {privatemsg_folder_recipient} ON {privatemsg}(recipient)");
      db_query("CREATE INDEX {privatemsg_folder_type} ON {privatemsg}(type)");
      db_query("CREATE INDEX {privatemsg_folder_author} ON {privatemsg}(author)");
      db_query("CREATE TABLE {privatemsg_folder} (
          fid           integer NOT NULL,
          uid           integer NOT NULL,
          name          varchar(255) not null,
          PRIMARY KEY (fid)
        )");
      db_query("CREATE TABLE {privatemsg_archive} (
          id            integer NOT NULL,
          author        integer NOT NULL,
          recipient     integer NOT NULL,
          subject       varchar(64) NOT NULL,
          message       text NOT NULL,
          timestamp     integer NOT NULL,
          hostname      varchar(255) NOT NULL,
          format        smallint NOT NULL DEFAULT 0,
          folder        integer NOT NULL,
          thread        int NOT NULL DEFAULT 0,
          PRIMARY KEY (id)
        )");
      db_query("CREATE INDEX {privatemsg_archive_recipient} ON {privatemsg_archive}(recipient)");
      db_query('CREATE SEQUENCE {privatemsg}_id_seq INCREMENT 1 START 1');
      db_query('CREATE SEQUENCE {privatemsg_folder}_fid_seq INCREMENT 1 START 1');
      db_query("CREATE TABLE {privatemsg_mail_edit} (
          type varchar(255) NOT NULL,
          mailkey varchar(255) NOT NULL,
          PRIMARY KEY  (mailkey)
        ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
      db_query('CREATE TABLE {privatemsg_block_user} (
          author int unsigned NOT NULL,
          recipient int unsigned NOT NULL,
          PRIMARY KEY (author, recipient)
        )');
      db_query("create or replace function unix_timestamp(timestamp with time zone)
        returns int as '
        declare
           date alias for \$1;
           timezero timestamp;
           offset interval;
        begin
           timezero := timestamp ''1970-1-1 00:00'' at time zone ''utc'';
           offset := date-timezero;

           return (extract(''days'' from offset)*86400+
                   extract(''hours'' from offset)*3600+
                   extract(''minutes'' from offset)*60+
                   extract(''seconds'' from offset))::int;
        end;
        ' language 'plpgsql'");
      db_query("create or replace function unix_timestamp(timestamp without time zone)
        returns int as '
        declare
           date alias for \$1;
           timezero timestamp;
           offset interval;
        begin
           timezero := timestamp ''1970-1-1 00:00'' at time zone ''utc'';
           offset := date-timezero;

           return (extract(''days'' from offset)*86400+
                   extract(''hours'' from offset)*3600+
                   extract(''minutes'' from offset)*60+
                   extract(''seconds'' from offset))::int;
        end;
        ' language 'plpgsql'");
      break;
  }
  // Sent messages folder
  db_query("INSERT INTO {privatemsg_folder} (fid, uid, name) VALUES (1, 0, 'Sent')");
  do {
    $i = db_next_id('{privatemsg_folder}_fid');
  } while ($i < 1);  // In case this api ever changes to start at zero..
  db_query("INSERT INTO {privatemsg_mail_edit} (type, mailkey) VALUES ('private-message', 'private-message')");
  db_query("INSERT INTO {mail_edit} (mailkey, subject, description) VALUES ('private-message', '', '%s')", st('When someone contacts you directly'));
}

function privatemsg_uninstall() {
  db_query("DROP TABLE {privatemsg}");
  db_query("DROP TABLE {privatemsg_folder}");
  db_query("DROP TABLE {privatemsg_archive}");
  if (db_table_exists('privatemsg_mails')) {
    db_query("DROP TABLE {privatemsg_mails}");
  }
  if (db_table_exists('privatemsg_mail_edit')) {
    db_query("DROP TABLE {privatemsg_mail_edit}");
  }
  if (db_table_exists('privatemsg_block_user')) {
    db_query("DROP TABLE {privatemsg_block_user}");
  }
  db_query("DELETE FROM {variable} WHERE name LIKE 'privatemsg_%'");
  cache_clear_all('variables', 'cache');
}

/* Upgrade on mysql from versions before 22-May-2003:
   Create privatemsg_archive/privatemsg_folder tables and insert one row, shown above^
   ALTER TABLE privatemsg ADD folder int unsigned NOT NULL;
   ALTER TABLE privatemsg ADD author_del tinyint unsigned NOT NULL;
   ALTER TABLE privatemsg ADD recipient_del tinyint unsigned NOT NULL;
   ALTER TABLE privatemsg ADD INDEX(folder);
   ALTER TABLE privatemsg CHANGE hostname hostname varchar(255) NOT NULL;
   Continue with steps below, but skip ALTER line for privatemsg_archive..
 *
 * Upgrade on mysql from versions before 29-Apr-2005:
   ALTER TABLE privatemsg CHANGE new newmsg tinyint UNSIGNED NOT NULL;
   ALTER TABLE privatemsg ADD format int NOT NULL DEFAULT '0';
   ALTER TABLE privatemsg_archive ADD format int NOT NULL DEFAULT '0';
   UPDATE privatemsg SET format=1;
   UPDATE privatemsg_archive SET format=1;
 */

function privatemsg_update_1() {
  return _system_update_utf8(array('privatemsg', 'privatemsg_archive', 'privatemsg_folder'));
}

function privatemsg_update_2() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $sql = 'ALTER TABLE {%s} MODIFY %s int unsigned NOT NULL';
      $seq = "INSERT INTO {sequences} (name, id) VALUES ('%s', %d)";
      break;
    case 'pgsql':
      $sql = 'ALTER TABLE {%s} ALTER COLUMN %s SET DEFAULT NULL';
      $seq = 'CREATE SEQUENCE %s_seq INCREMENT 1 START %d';
      break;
    default:
      return $ret;
  }
  foreach (array('privatemsg' => 'id', 'privatemsg_folder' => 'fid') as $table => $id) {
    $ret[] = update_sql(sprintf($sql, $table, $id));
    $max = db_result(db_query('SELECT max('. $id .') FROM {'. $table .'}'));
    if ($table == 'privatemsg') {
      $max = max($max, db_result(db_query('SELECT max(id) FROM {privatemsg_archive}')));
    }
    $ret[] = update_sql(sprintf($seq, '{'. $table .'}_'. $id, $max));
  }
  $ret[] = update_sql(sprintf($sql, 'privatemsg_archive', 'id'));
  return $ret;
}

function privatemsg_update_3() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql('ALTER TABLE {privatemsg} ADD thread int NOT NULL');
      $ret[] = update_sql('ALTER TABLE {privatemsg_archive} ADD thread int NOT NULL');
      break;
    case 'pgsql':
      foreach (array('privatemsg', 'privatemsg_archive') as $table) {
        $ret[] = update_sql("ALTER TABLE {$table} ADD thread int");
        $ret[] = update_sql("ALTER TABLE {$table} ALTER COLUMN thread SET DEFAULT 0");
        $ret[] = update_sql("UPDATE {$table} SET thread = 0");
        $ret[] = update_sql("ALTER TABLE {$table} ALTER COLUMN thread SET NOT NULL");
      }
      break;
  }
  return $ret;
}

function _privatemsg_abort_update(&$ret) {
  // Keep our caller update_data() from setting the installed_schema_version:
  $ret['#finished'] = FALSE;
  // Keep update_data()'s caller update_do_updates() from going into an endless loop (HACK!):
  unset($_SESSION['update_remaining'][key($_SESSION['update_remaining'])]);
}

function privatemsg_update_4() {
  $ret = array();

  if (!module_exists('mail_edit')) {
    // If Privatemsg 5.x-1.8 is replaced by 5.x-2.x and the Mail Editor module is not enabled, then this will fail!
    module_disable(array('privatemsg'));
    $ret[] = array('success' => FALSE, 'query' => 'The required Mail Editor module is missing &mdash; the Privatemsg module has been disabled!<br>Be sure to re-run the database update after re-enabling the Privatemsg module!');
    _privatemsg_abort_update($ret);
    return $ret;
  }

  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      $ret[] = update_sql("ALTER TABLE {privatemsg} ADD type varchar(255) NOT NULL default '', ADD KEY (type)");
      if (!db_table_exists('privatemsg_mail_edit')) {
        if (db_table_exists('privatemsg_mails')) {
          $ret[] = update_sql('RENAME TABLE {privatemsg_mails} TO {privatemsg_mail_edit}');
        }
        else {
          $ret[] = update_sql("CREATE TABLE {privatemsg_mail_edit} (
              type varchar(255) NOT NULL,
              mailkey varchar(255) NOT NULL,
              PRIMARY KEY  (mailkey)
            ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
        }
      }
      $ret[] = update_sql("ALTER TABLE {privatemsg} CHANGE subject subject varchar(255) NOT NULL default ''");
      if (!db_table_exists('privatemsg_block_user')) {
        $ret[] = update_sql('CREATE TABLE {privatemsg_block_user} (
            author int unsigned NOT NULL,
            recipient int unsigned NOT NULL,
            PRIMARY KEY (author, recipient)
          )  /*!40100 DEFAULT CHARACTER SET utf8 */');
      }
      break;
    case 'pgsql':
      db_add_column($ret, 'privatemsg', 'type', 'varchar(255)', array('not null' => TRUE, 'default' => "''"));
      $ret[] = update_sql("CREATE INDEX {privatemsg_folder_type} ON {privatemsg}(type)");
      if (!db_table_exists('privatemsg_mail_edit')) {
        if (db_table_exists('privatemsg_mails')) {
          $ret[] = update_sql('ALTER TABLE {privatemsg_mails} RENAME TO {privatemsg_mail_edit}');
        }
        else {
          $ret[] = update_sql("CREATE TABLE {privatemsg_mail_edit} (
              type varchar(255) NOT NULL,
              mailkey varchar(255) NOT NULL,
              PRIMARY KEY  (mailkey)
            ) /*!40100 DEFAULT CHARACTER SET utf8 */;");
        }
      }
      db_change_column($ret, 'privatemsg', 'subject', 'subject', 'varchar(255)', array('not null' => TRUE, 'default' => "''"));
      if (!db_table_exists('privatemsg_block_user')) {
        $ret[] = update_sql('CREATE TABLE {privatemsg_block_user} (
            author int unsigned NOT NULL,
            recipient int unsigned NOT NULL,
            PRIMARY KEY (author, recipient)
          )');
      }
      break;
  }
  $ret[] = update_sql("INSERT INTO {privatemsg_mail_edit} (type, mailkey) VALUES ('private-message', 'private-message')");

  if (!module_exists('subscriptions')) {
    // If Privatemsg 5.x-1.8 is replaced by 5.x-2.x and the Subscriptions module is not enabled, then Privatemsg will not run correctly!
    module_disable(array('privatemsg'));
    $ret[] = array('success' => FALSE, 'query' => 'The required Subscriptions module is missing &mdash; the Privatemsg module has been disabled!');
  }
  return $ret;
}

function privatemsg_update_5() {
  $ret = array();

  if (!module_exists('privatemsg')) {
    // privatemsg_update_5() is called even if privatemsg_update_4() disabled Privatemsg, so we have to abort here...
    $ret[] = array('success' => FALSE, 'query' => 'The Privatemsg module is disabled.<br>Be sure to re-run the database update after re-enabling the Privatemsg module!');
    _privatemsg_abort_update($ret);
    return $ret;
  }

  if (!db_result(db_query("SELECT COUNT(*) FROM {mail_edit} WHERE mailkey = 'private-message'"))) {
    $ret[] = update_sql("INSERT INTO {mail_edit} (mailkey, subject, description) VALUES ('private-message', '', '%s')", st('When someone contacts you directly'));
  }

  if (drupal_get_installed_schema_version('subscriptions') < 1) {
    module_disable(array('privatemsg'));
    $ret[] = array('success' => FALSE, 'query' => 'You must upgrade the Subscriptions module to run this version of the Privatemsg module &mdash; the Privatemsg module has been disabled!');
  }
  else {
    $ret[] = array('success' => TRUE, 'query' => 'Subscriptions module: OK');
  }
  return $ret;
}

function privatemsg_update_6() {
  $ret = array();
  switch ($GLOBALS['db_type']) {
    case 'mysql':
    case 'mysqli':
      // add name_length column (for sorting results by the length of username - 
      // this needs a whole new column for performance on autocomplete callbacks)
      $ret[] = update_sql("ALTER TABLE {users} ADD name_length INT NOT NULL DEFAULT 0");
      $ret[] = update_sql("UPDATE {users} SET name_length = LENGTH(name)");
      // keep the column automatically updated ...
      // note: the following will fail if the database user used by drupal
      // does not have the SUPER privelege, but the update script will tell you,
      // and you will have to create these 2 triggers manually
      $ret[] = update_sql("CREATE TRIGGER user_name_length_insert BEFORE INSERT ON {users} FOR EACH ROW SET NEW.name_length = LENGTH(NEW.name)");
      $ret[] = update_sql("CREATE TRIGGER user_name_length_update BEFORE UPDATE ON {users} FOR EACH ROW SET NEW.name_length = LENGTH(NEW.name)");
  }
  return $ret;
}
